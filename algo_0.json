[
 {
  "id": 0,
  "type": "bubble",
  "style": {
   "default": "bubble"
  },
  "x": 0,
  "y": 0,
  "title": ".",
  "text": "root",
  "height": 42,
  "width": 36
 },
 {
  "id": 26,
  "type": "bubble",
  "style": {
   "default": "bubble"
  },
  "x": -490,
  "y": 990,
  "title": ".",
  "text": "[s=28]ğŸŒ³ ğŸŒ² ğŸŒ´ ğŸŒµ ğŸ„ ğŸŒ¾ ğŸ‹ ğŸ ğŸªµ ğŸª¨ ğŸŒ¿ â˜˜ï¸ ğŸ€ ğŸƒ ğŸ‚ ğŸ ğŸŒ± ğŸª´ ğŸŒ¸ ğŸŒº ğŸŒ» ğŸŒ¼ ğŸŒ· ğŸŒ¹ ğŸ¥€ ğŸŒ³ ğŸŒ² ğŸŒ´ ğŸŒµ ğŸ„ ğŸŒ¾ ğŸ‹ ğŸ ğŸªµ ğŸª¨ ğŸŒ¿ â˜˜ï¸ ğŸ€ ğŸƒ ğŸ‚ ğŸ ğŸŒ± ğŸª´ ğŸŒ¸ ğŸŒº ğŸŒ» ğŸŒ¼ ğŸŒ· ğŸŒ¹ ğŸ¥€[/s]",
  "height": 200,
  "width": 200,
  "tag": [
   "emoji"
  ]
 },
 {
  "id": 27,
  "type": "bubble",
  "style": {
   "default": "bubble"
  },
  "x": -487,
  "y": 712,
  "title": ".",
  "text": "[s=28]ğŸ  ğŸ¡ ğŸ˜ï¸ ğŸ¢ ğŸ¬ ğŸ­ ğŸ—ï¸ ğŸ›ï¸ ğŸ¦ ğŸ« ğŸ¥ ğŸ¨ ğŸ™ï¸ ğŸŒ† ğŸŒ‡ ğŸŒƒ ğŸ—¼ ğŸ—½ ğŸ§±ğŸš† ğŸš‡ ğŸšˆ ğŸš‰ ğŸš„ ğŸš… ğŸš ğŸš ğŸš‹ ğŸšƒ ğŸš‚ğŸš— ğŸš™ ğŸš• ğŸš“ ğŸš‘ ğŸš’ ğŸšŒ ğŸš ğŸš ğŸšš ğŸš› ğŸšœ ğŸï¸ ğŸ›µ ğŸ›º ğŸš² ğŸš¨[/s]",
  "height": 292,
  "width": 435,
  "tag": [
   "emoji"
  ]
 },
 {
  "id": 28,
  "type": "bubble",
  "style": {
   "default": "bubble"
  },
  "x": -487,
  "y": 490,
  "title": ".",
  "text": "[s=28]ğŸ ğŸ¡ğŸ˜ï¸ğŸšï¸ğŸ›–ğŸ›–ğŸ¢ğŸ¢ğŸ¬ğŸ£ğŸ¤ğŸ¥ğŸ¨ğŸ¦ğŸ«ğŸ›ï¸ğŸ­ğŸ­ğŸ—ï¸ğŸ§±[/s]",
  "height": 200,
  "width": 200,
  "tag": [
   "emoji"
  ]
 },
 {
  "id": 29,
  "type": "bubble",
  "style": {
   "default": "bubble"
  },
  "x": -141,
  "y": 1017,
  "title": ".",
  "text": "[s=28]ğŸ”ï¸ â›°ï¸ ğŸï¸ ğŸŒ„ ğŸŒ… ğŸŒŠ ğŸŒŠ ğŸï¸ ğŸ–ï¸ ğŸï¸ ğŸ•ï¸ ğŸŒŠ ğŸŒ…[/s]",
  "height": 200,
  "width": 200,
  "tag": [
   "emoji"
  ]
 },
 {
  "id": 30,
  "type": "bubble",
  "style": {
   "default": "bubble"
  },
  "x": 171,
  "y": 953,
  "title": ".",
  "text": "[s=100]ğŸ”ï¸\nğŸ”ï¸\nğŸ”ï¸[/s].",
  "height": 473,
  "width": 140
 },
 {
  "id": 32,
  "type": "bubble",
  "style": {
   "default": "bubble"
  },
  "x": 1741,
  "y": 1088,
  "title": ".",
  "text": "[s=100]ğŸ›[/s]",
  "height": 176,
  "width": 153
 },
 {
  "id": 33,
  "type": "bubble",
  "style": {
   "default": "bubble"
  },
  "x": 161,
  "y": 1478,
  "title": ".",
  "text": "[s=100]ğŸ•ï¸[/s]",
  "height": 162,
  "width": 168
 },
 {
  "id": 34,
  "type": "goto",
  "style": {
   "default": "goto"
  },
  "x": 99,
  "y": 9,
  "title": ".",
  "text": "pointerBasic",
  "gotoid": "1"
 },
 {
  "id": 49,
  "type": "bubble",
  "style": {
   "default": "bubble"
  },
  "x": 1414,
  "y": 1194,
  "title": ".",
  "text": "go full length of array",
  "maximize": true,
  "height": 56,
  "width": 164
 },
 {
  "id": 50,
  "type": "bubble",
  "style": {
   "default": "bubble"
  },
  "x": 1411,
  "y": 1265,
  "title": ".",
  "text": "i = 0; i < n\ni = 0; i <= n-1\n\ni = 1; i <= n",
  "height": 100,
  "width": 100,
  "show": true
 },
 {
  "id": 51,
  "type": "bubble",
  "style": {
   "default": "bubble"
  },
  "x": 1338,
  "y": 1617,
  "title": ".",
  "text": "\n[] [] [] [] [] \nn = 5\nn//2 = 2\n0 to <2  |  2 to <5\n[0] [1]    [2] [3] [4] \nOdd moves to right",
  "height": 172,
  "width": 140
 },
 {
  "id": 52,
  "type": "bubble",
  "style": {
   "default": "bubble"
  },
  "x": 1589,
  "y": 1621,
  "title": ".",
  "text": "[] [] [] []\nn = 4\nn//2 = 2\n0 to <2  |  2 to <4\n[0] [1]    [2] [3]\nequal split",
  "height": 140,
  "width": 153
 },
 {
  "id": 53,
  "type": "bubble",
  "style": {
   "default": "bubble"
  },
  "x": 1826,
  "y": 1615,
  "title": ".",
  "text": "[]\nn = 1\nn//2 = 0\n0 to <0  |  0 to <1\ninvalid  |  [0]\nodd to right",
  "height": 143,
  "width": 150
 },
 {
  "id": 54,
  "type": "bubble",
  "style": {
   "default": "bubble"
  },
  "x": 1709,
  "y": 1233,
  "title": ".",
  "text": "0 to < [s=24]n[/s]\nRuns [s=24]n[/s] times, all elements\n\n0 to < [s=24]n-1[/s]\nRuns [s=24]n-1[/s] times, except last\n\nbasically the value of < N",
  "height": 232,
  "width": 212
 },
 {
  "id": 55,
  "type": "bubble",
  "style": {
   "default": "bubble"
  },
  "x": 1218,
  "y": 1196,
  "title": ".",
  "text": "[s=100]ğŸ“[/s]",
  "height": 163,
  "width": 142
 },
 {
  "id": 56,
  "type": "bubble",
  "style": {
   "default": "bubble"
  },
  "x": 1033,
  "y": 1617,
  "title": ".",
  "text": "[s=50]ğŸ§¹floor[/s]",
  "height": 112,
  "width": 238
 },
 {
  "id": 57,
  "type": "bubble",
  "style": {
   "default": "bubble"
  },
  "x": 2505,
  "y": 811,
  "title": ".",
  "text": "full code\n\n#include <stdio.h>\n#include <stdbool.h>\n\n// Swap function\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\n// Bubble Sort with early exit\nvoid bubbleSort(int arr[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n        bool swapped = false;\n\n        for (int j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                swap(&arr[j], &arr[j + 1]);\n                swapped = true;\n            }\n        }\n\n        // If no two elements were swapped, the array is already sorted\n        if (!swapped)\n            break;\n    }\n}\n\n// Print the array\nvoid printArray(int arr[], int n) {\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    printf(\"\\n\");\n}\n\n// Main function\nint main() {\n    int arr[] = {64, 25, 12, 22, 11};\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    printf(\"Original array: \");\n",
  "height": 470,
  "width": 351,
  "tag": [
   "bubblesort"
  ]
 },
 {
  "id": 58,
  "type": "bubble",
  "style": {
   "default": "bubble"
  },
  "x": 2491,
  "y": 677,
  "title": ".",
  "text": "[s=50]ğŸ«§[/s]",
  "height": 111,
  "width": 104,
  "tag": [
   "bubblesort"
  ]
 },
 {
  "id": 59,
  "type": "goto",
  "style": {
   "default": "goto"
  },
  "x": 99,
  "y": 52,
  "title": ".",
  "text": "bubble",
  "gotoid": "58"
 },
 {
  "id": 61,
  "type": "bubble",
  "style": {
   "default": "bubble"
  },
  "x": 4055,
  "y": 662,
  "title": ".",
  "text": "[c=#ff79c6]file list.h[/c]\n\n#[g=62]ifndef[/g] LIST_H\n#define LIST_H\n#include <stdlib.h>\n...\n#endif",
  "height": 93,
  "width": 92
 },
 {
  "id": 62,
  "type": "bubble",
  "style": {
   "default": "bubble"
  },
  "x": 6069,
  "y": 515,
  "title": ".",
  "text": "[c=#bd93f9]What does ifndef do ?[/c]\n\nIn a file\n\n#include \"list.h\"\n#include \"list.h\"\nThe compiler might see duplicate definitions, leading to compilation errors.",
  "height": 128,
  "width": 152
 },
 {
  "id": 63,
  "type": "bubble",
  "style": {
   "default": "bubble"
  },
  "x": 4059,
  "y": 565,
  "title": ".",
  "text": "[s=33]Linked list[/s]",
  "height": 64,
  "width": 224
 },
 {
  "id": 64,
  "type": "bubble",
  "style": {
   "default": "bubble"
  },
  "x": 4177,
  "y": 667,
  "title": ".",
  "text": "[c=#ff79c6]list element[/c]\ntypedef struct ListElmt_ {\nvoid *data;\nstruct ListElmt_ *next;\n} ListElmt;",
  "height": 81,
  "width": 119
 },
 {
  "id": 65,
  "type": "bubble",
  "style": {
   "default": "bubble"
  },
  "x": 4340,
  "y": 662,
  "title": ".",
  "text": "[c=#ff79c6]list[/c]\ntypedef struct List_ {\nint size;\nint (*match)(const void *key1, const void *key2);\nvoid (*destroy)(void *data);\nListElmt *head;\nListElmt *tail;\n} List;",
  "height": 103,
  "width": 230
 },
 {
  "id": 66,
  "type": "bubble",
  "style": {
   "default": "bubble"
  },
  "x": 4600,
  "y": 667,
  "title": ".",
  "text": "[c=#ff79c6]public interface[/c]\nIf you dont define it here. then when doing #include \"list.h\", it wont be visible\n\nvoid list_init(List *list, void (*destroy)(void *data));\nvoid list_destroy(List *list);\nint list_ins_next(List *list, ListElmt *element, const void *data);\nint list_rem_next(List *list, ListElmt *element, void **data);\n\n#define list_size(list) ((list)->size)\n#define list_head(list) ((list)->head)\n#define list_tail(list) ((list)->tail)\n#define list_is_head(list, element) ((element) == (list)->head ? 1 : 0)\n#define list_is_tail(element) ((element)->next == NULL ? 1 : 0)\n#define list_data(element) ((element)->data)\n#define list_next(element) ((element)->next)",
  "height": 182,
  "width": 386
 },
 {
  "id": 67,
  "type": "goto",
  "style": {
   "default": "goto"
  },
  "x": 99,
  "y": 94,
  "title": ".",
  "text": "linkedList",
  "gotoid": "63"
 },
 {
  "id": 68,
  "type": "bubble",
  "style": {
   "default": "bubble"
  },
  "x": 6619,
  "y": 1705,
  "title": ".",
  "text": "#include <iostream>     // std::cout, std::endl\n#include <string>       // std::string\n#include <memory>       // std::unique_ptr, std::make_unique\n\n// Data structure to hold user info\nstruct Data {\n    int id;                 // Unique ID\n    std::string name;       // Name string\n\n    Data(int id_, const std::string& name_) : id(id_), name(name_) {}\n};\n\nclass LinkedList {\nprivate:\n    // Internal Node structure with data and unique_ptr to next node\n    struct Node {\n        Data data;\n        std::unique_ptr<Node> next;\n\n        Node(const Data& d) : data(d), next(nullptr) {}\n    };\n\n    std::unique_ptr<Node> head; // Pointer to first node\n\npublic:\n    LinkedList() = default;      // Default constructor\n    ~LinkedList() = default;     // Default destructor (unique_ptr cleans up)\n\n    LinkedList(const LinkedList&) = delete;            // No copy constructor\n    LinkedList& operator=(const LinkedList&) = delete; // No copy assignment\n\n    LinkedList(LinkedList&&) = default;     // Move constructor\n    LinkedList& operator=(LinkedList&&) = default; // Move assignment\n\n    // Insert at head\n    void insertAtHead(const Data& d) {\n        auto newNode = std::make_unique<Node>(d);\n        newNode->next = std::move(head);\n        head = std::move(newNode);\n    }\n\n    // Insert at end\n    void insertAtEnd(const Data& d) {\n        auto newNode = std::make_unique<Node>(d);\n        if (!head) {              // Empty list, new node becomes head\n            head = std::move(newNode);\n            return;\n        }\n        Node* temp = head.get();  // Non-owning pointer to traverse\n        while (temp->next) {      // Traverse to last node\n            temp = temp->next.get();\n        }\n        temp->next = std::move(newNode); // Link last node to new node\n    }\n\n    // Insert at a specific position (0-based index)\n    void insertAtPosition(const Data& d, size_t pos) {\n        if (pos == 0) {\n            insertAtHead(d);\n            return;\n        }\n\n        Node* temp = head.get();\n        size_t index = 0;\n\n        // Traverse to node before insertion point\n        while (temp && index < pos - 1) {\n            temp = temp->next.get();\n            ++index;\n        }\n\n        if (!temp) {  // Position out of bounds; insert at end\n            insertAtEnd(d);\n            return;\n        }\n\n        // Create new node\n        auto newNode = std::make_unique<Node>(d);\n        // Link new node's next to temp's next\n        newNode->next = std::move(temp->next);\n        // Link temp's next to new node\n        temp->next = std::move(newNode);\n    }\n\n    // Delete from head\n    void deleteFromHead() {\n        if (!head) {\n            std::cout << \"List is empty, nothing to delete at head.\\n\";\n            return;\n        }\n        head = std::move(head->next); // unique_ptr automatically deletes old head\n    }\n\n    // Delete from end\n    void deleteFromEnd() {\n        if (!head) {\n            std::cout << \"List is empty, nothing to delete at end.\\n\";\n            return;\n        }\n\n        if (!head->next) {\n            head.reset();  // Only one node, delete head\n            return;\n        }\n\n        Node* temp = head.get();\n        // Traverse until node before last node\n        while (temp->next->next) {\n            temp = temp->next.get();\n        }\n        temp->next.reset();  // Delete last node\n    }\n\n    // Delete at a specific position (0-based index)\n    void deleteAtPosition(size_t pos) {\n        if (!head) {\n            std::cout << \"List is empty, nothing to delete.\\n\";\n            return;\n        }\n\n        if (pos == 0) {\n            deleteFromHead();\n            return;\n        }\n\n        Node* temp = head.get();\n        size_t index = 0;\n\n        // Traverse to node before deletion point\n        while (temp->next && index < pos - 1) {\n            temp = temp->next.get();\n            ++index;\n        }\n\n        if (!temp->next) {\n            std::cout << \"Position out of bounds, nothing to delete.\\n\";\n            return;\n        }\n\n        // Bypass and delete node at position\n        temp->next = std::move(temp->next->next);\n    }\n\n    // Display the list contents\n    void display() const {\n        const Node* temp = head.get();\n        if (!temp) {\n            std::cout << \"List is empty.\\n\";\n            return;\n        }\n\n        while (temp) {\n            std::cout << \"ID: \" << temp->data.id << \", Name: \" << temp->data.name << \"\\n\";\n            temp = temp->next.get();\n        }\n    }\n};\n\nint main() {\n    LinkedList list;\n\n    // Insert some nodes\n    list.insertAtHead(Data(1, \"Alice\"));\n    list.insertAtEnd(Data(2, \"Bob\"));\n    list.insertAtPosition(Data(3, \"Charlie\"), 1);  // Insert at middle position\n\n    std::cout << \"List after inserts:\\n\";\n    list.display();\n\n    // Delete head node\n    list.deleteFromHead();\n    std::cout << \"\\nAfter deleting from head:\\n\";\n    list.display();\n\n    // Delete last node\n    list.deleteFromEnd();\n    std::cout << \"\\nAfter deleting from end:\\n\";\n    list.display();\n\n    // Delete node at position 0 (only node left)\n    list.deleteAtPosition(0);\n    std::cout << \"\\nAfter deleting at position 0:\\n\";\n    list.display();\n\n    return 0;\n}\n",
  "height": 1878,
  "width": 612
 },
 {
  "id": 69,
  "type": "goto",
  "style": {
   "default": "goto"
  },
  "x": 341,
  "y": -3,
  "title": ".",
  "text": "linkedlistcpp",
  "gotoid": "68"
 },
 {
  "id": 70,
  "type": "bubble",
  "style": {
   "default": "bubble"
  },
  "x": 5762,
  "y": 1608,
  "title": ".",
  "text": "[c=#f1fa8c]c++ constructor[/c]\n\nData(int id_, const std::string& name_) : id(id_), name(name_) {}\n\nData() is a [c=#50fa7b]constructor[/c]\nid_, name_ are parameters to constructor\npost_ is a [c=#50fa7b]convention[/c] when names are same\n\nc++ has init and assignment\n\ninit:\nid(id_), name(name_) is initialization\n\nassignment:\nData(int id_, const std::string& name_) {\n    id = id_;\n    name = name_;\n}\n\n[c=#ff79c6]Note:[/c] \nThe name even though uses a reference & it is copied over to struct because struct likes to [c=#50fa7b]OWN[/c] things\n\ninit -> direct copy\nassignment -> create a local variable name inside {} -> set it to default '' -> assign to that \n\none extra step. Init better\nfor int it doesnt matter\n\nNote: The struct basically makes a separate copy of the string to itself",
  "height": 332,
  "width": 372
 },
 {
  "id": 71,
  "type": "goto",
  "style": {
   "default": "goto"
  },
  "x": 5095,
  "y": 1416,
  "title": ".",
  "text": "c++",
  "gotoid": "70"
 },
 {
  "id": 72,
  "type": "goto",
  "style": {
   "default": "goto"
  },
  "x": 300,
  "y": -2,
  "title": ".",
  "text": "cpp",
  "gotoid": "70"
 },
 {
  "id": 73,
  "type": "quiz",
  "style": {
   "default": "quiz",
   "fontFamily": "Comic Sans MS"
  },
  "x": 2948,
  "y": 818,
  "title": ".",
  "text": [
   {
    "q": "How many nested loops are present in the bubbleSort function?",
    "options": [
     "1",
     "2",
     "3",
     "4"
    ],
    "a": [
     1
    ],
    "h": "The bubbleSort function has 2 nested loops. Its time complexity is O(nÂ²) in the worst case due to these nested iterations."
   },
   {
    "q": "What is the condition for the outer loop in the bubbleSort function?",
    "options": [
     "i < n",
     "i < n - 1",
     "i <= n",
     "i <= n - 1"
    ],
    "a": [
     1
    ],
    "h": "Ensures it skips last element because inside loop has j+1"
   },
   {
    "q": "Fill in the blank: The inner loop in the bubbleSort function runs while ____ ",
    "a": [
     "j<n-i-1"
    ]
   },
   {
    "q": "The loop 'int i = 0; i < n - 1; i++' in bubbleSort runs only when there are at least how many elements in the array?",
    "options": [
     "0",
     "1",
     "2",
     "n"
    ],
    "a": [
     2
    ],
    "h": "The outer loop runs only if n - 1 > 0, meaning there must be at least 2 elements for the loop to execute."
   },
   {
    "q": "What is the purpose of the 'swapped' variable in the bubbleSort function?",
    "options": [
     "To count how many swaps are made",
     "To reverse the array after sorting",
     "To check if any elements were swapped during a pass",
     "To keep track of the loop index"
    ],
    "a": [
     2
    ],
    "h": "bool swapped = false in outer loop \n swapped = true in inner loop \n if (!swapped) break in outer loop"
   },
   {
    "q": "Does bool swapped recreate variable inside outer loop every time",
    "options": [
     "yes",
     "no",
     "maybe",
     "probably no"
    ],
    "a": [
     3
    ],
    "h": "Yes, a new bool swapped is created per iteration (by C rules) \n but most modern compilers reuses the same memory location for each iteration]n Declaring swapped inside the loop is a best practice in this case, for readability, safety, and scoping.ğŸ˜±"
   }
  ],
  "height": 200,
  "width": 200
 },
 {
  "id": 74,
  "type": "card",
  "style": {
   "default": "card"
  },
  "x": 676,
  "y": 559,
  "text": "pointer",
  "root": true,
  "child": [
   75,
   77,
   83,
   95,
   100,
   103,
   110,
   112
  ]
 },
 {
  "id": 75,
  "type": "card",
  "style": {
   "default": "card"
  },
  "x": 732,
  "y": 685,
  "text": "?",
  "child": [
   76
  ]
 },
 {
  "id": 76,
  "type": "card",
  "style": {
   "default": "card"
  },
  "x": 748,
  "y": 601,
  "text": "variable that stores address of piece of data",
  "child": []
 },
 {
  "id": 77,
  "type": "card",
  "style": {
   "default": "card"
  },
  "x": 732,
  "y": 658,
  "text": "lc",
  "child": [
   78
  ]
 },
 {
  "id": 78,
  "type": "card",
  "style": {
   "default": "card"
  },
  "x": 752,
  "y": 603,
  "text": "declare",
  "child": [
   91,
   80
  ]
 },
 {
  "id": 79,
  "type": "card",
  "style": {
   "default": "card"
  },
  "x": 853,
  "y": 557,
  "text": "T *p\nT* p\nT - Datatype. Must match target type ( except void)",
  "child": []
 },
 {
  "id": 80,
  "type": "card",
  "style": {
   "default": "card"
  },
  "x": 810,
  "y": 547,
  "text": "eg",
  "child": [
   81,
   82
  ]
 },
 {
  "id": 81,
  "type": "card",
  "style": {
   "default": "card"
  },
  "x": 834,
  "y": 624,
  "text": "int a = 2;\nint *p = &a;",
  "child": []
 },
 {
  "id": 82,
  "type": "card",
  "style": {
   "default": "card"
  },
  "x": 834,
  "y": 561,
  "text": "int a=2;\nint *p;\np=&a;",
  "child": []
 },
 {
  "id": 83,
  "type": "card",
  "style": {
   "default": "card"
  },
  "x": 732,
  "y": 627,
  "text": "ğŸ”",
  "child": [
   84,
   92
  ]
 },
 {
  "id": 84,
  "type": "card",
  "style": {
   "default": "card"
  },
  "x": 764,
  "y": 634,
  "text": "select",
  "child": [
   85,
   86,
   88
  ]
 },
 {
  "id": 85,
  "type": "card",
  "style": {
   "default": "card"
  },
  "x": 815,
  "y": 562,
  "text": "basic",
  "child": [
   90
  ]
 },
 {
  "id": 86,
  "type": "card",
  "style": {
   "default": "card"
  },
  "x": 815,
  "y": 535,
  "text": "jump",
  "child": [
   87
  ]
 },
 {
  "id": 87,
  "type": "card",
  "style": {
   "default": "card"
  },
  "x": 857,
  "y": 490,
  "text": "int *p = &a;\np is 1000\nsizeof(int) 4\n\nprintf(\"%d\\n\", p+1) \n1004\n",
  "child": []
 },
 {
  "id": 88,
  "type": "card",
  "style": {
   "default": "card"
  },
  "x": 815,
  "y": 504,
  "text": "ğŸ—‘ï¸ Garbage ",
  "child": [
   89
  ]
 },
 {
  "id": 89,
  "type": "card",
  "style": {
   "default": "card"
  },
  "x": 908,
  "y": 505,
  "text": "printf(\"%d\\n\", *(p + 97349879439) )",
  "child": []
 },
 {
  "id": 90,
  "type": "card",
  "style": {
   "default": "card"
  },
  "x": 858,
  "y": 562,
  "text": "printf(\"%d\\n\", *p )",
  "child": []
 },
 {
  "id": 91,
  "type": "card",
  "style": {
   "default": "card"
  },
  "x": 810,
  "y": 573,
  "text": "basic",
  "child": [
   79
  ]
 },
 {
  "id": 92,
  "type": "card",
  "style": {
   "default": "card"
  },
  "x": 764,
  "y": 562,
  "text": "update",
  "child": [
   93
  ]
 },
 {
  "id": 93,
  "type": "card",
  "style": {
   "default": "card"
  },
  "x": 815,
  "y": 562,
  "text": "copy",
  "child": [
   94
  ]
 },
 {
  "id": 94,
  "type": "card",
  "style": {
   "default": "card"
  },
  "x": 855,
  "y": 516,
  "text": "int a ;\nint *p ;\na = 10;\np = &a ;\nint b = 20;\n*p = b;",
  "child": []
 },
 {
  "id": 95,
  "type": "card",
  "style": {
   "default": "card"
  },
  "x": 732,
  "y": 599,
  "text": "typecast",
  "child": [
   97
  ]
 },
 {
  "id": 96,
  "type": "card",
  "style": {
   "default": "card"
  },
  "x": 856,
  "y": 368,
  "text": "int a = 1025\n00000000 0000000 00000100 00000001\nAddress goes from right to left â¬…ï¸\nint *p = &a\n\nprintf(\"%d, %d\", p, *p)\n65436354, 1025\n\nchar *p0 ;\np0 = (char*)p;\n\n! print as int\nprintf(\"%d, %d\", p0, *p0)\n65436354, 1",
  "child": [
   99
  ]
 },
 {
  "id": 97,
  "type": "card",
  "style": {
   "default": "card"
  },
  "x": 795,
  "y": 490,
  "text": "int2char",
  "child": [
   96
  ]
 },
 {
  "id": 98,
  "type": "card",
  "style": {
   "default": "card"
  },
  "x": 1167,
  "y": 368,
  "text": "What is \nprintf(\"%d, %d\", p+1, *(p+1))\nprintf(\"%d, %d\", p0+1, *(p0+1))\n\n65436358, Garbage value\n65436355, 4",
  "child": []
 },
 {
  "id": 99,
  "type": "card",
  "style": {
   "default": "card"
  },
  "x": 1125,
  "y": 414,
  "text": "jump",
  "child": [
   98
  ]
 },
 {
  "id": 100,
  "type": "card",
  "style": {
   "default": "card"
  },
  "x": 732,
  "y": 572,
  "text": "p2p",
  "child": [
   101
  ]
 },
 {
  "id": 101,
  "type": "card",
  "style": {
   "default": "card"
  },
  "x": 765,
  "y": 465,
  "text": "?",
  "child": [
   102
  ]
 },
 {
  "id": 102,
  "type": "card",
  "style": {
   "default": "card"
  },
  "x": 781,
  "y": 428,
  "text": "int **p declaration\n\n**p  value\n*p address - point to something else\np address of pointer - usually not modified\n",
  "child": []
 },
 {
  "id": 103,
  "type": "card",
  "style": {
   "default": "card"
  },
  "x": 732,
  "y": 541,
  "text": "âŒ\n",
  "child": [
   104
  ]
 },
 {
  "id": 104,
  "type": "card",
  "style": {
   "default": "card"
  },
  "x": 764,
  "y": 541,
  "text": "danglingğŸ¦¥pointer",
  "child": [
   105,
   106
  ]
 },
 {
  "id": 105,
  "type": "card",
  "style": {
   "default": "card"
  },
  "x": 896,
  "y": 543,
  "text": "int f(int **iptr) {\nint a = 10;\n*iptr = &a;\nreturn 0;\n}\n\n//a is automatic variable in stack\nautomatically deallocated during function exit",
  "child": []
 },
 {
  "id": 106,
  "type": "card",
  "style": {
   "default": "card"
  },
  "x": 896,
  "y": 410,
  "text": "âœ…",
  "child": [
   107,
   108
  ]
 },
 {
  "id": 107,
  "type": "card",
  "style": {
   "default": "card"
  },
  "x": 927,
  "y": 370,
  "text": "#include <stdlib.h>\nint g(int **iptr) {\nif ((*iptr = (int *)malloc(sizeof(int))) == NULL)\nreturn -1;\nreturn 0;\n}\n\n//heap allocation\nUser responsibility to free",
  "child": []
 },
 {
  "id": 108,
  "type": "card",
  "style": {
   "default": "card"
  },
  "x": 927,
  "y": 325,
  "text": "!",
  "child": [
   109
  ]
 },
 {
  "id": 109,
  "type": "card",
  "style": {
   "default": "card"
  },
  "x": 941,
  "y": 307,
  "text": "Memory leaks\nblocks of storage that are allocated but never freed by a program, even\nwhen no longer in use.",
  "child": []
 },
 {
  "id": 110,
  "type": "card",
  "style": {
   "default": "card"
  },
  "x": 732,
  "y": 513,
  "text": "!",
  "child": [
   111
  ]
 },
 {
  "id": 111,
  "type": "card",
  "style": {
   "default": "card"
  },
  "x": 750,
  "y": 418,
  "text": "pointer space is usually 1 machine word\r\n1 byte\r\nâš ï¸may vary based on 32bit 64bit\r\n\r\nint *p => only pointer spaceğŸ§  allocated\r\nint a=>only now variable got spaceğŸ§ \r\np=&a",
  "child": []
 },
 {
  "id": 112,
  "type": "card",
  "style": {
   "default": "card"
  },
  "x": 732,
  "y": 459,
  "text": "as f param",
  "child": [
   113,
   115,
   117
  ]
 },
 {
  "id": 113,
  "type": "card",
  "style": {
   "default": "card"
  },
  "x": 809,
  "y": 487,
  "text": "basic",
  "child": [
   114
  ]
 },
 {
  "id": 114,
  "type": "card",
  "style": {
   "default": "card"
  },
  "x": 850,
  "y": 467,
  "text": "void update(int *p){*p = 42;}\nint main(){\nint value=10; update(&value)\n}",
  "child": []
 },
 {
  "id": 115,
  "type": "card",
  "style": {
   "default": "card"
  },
  "x": 809,
  "y": 461,
  "text": "p2p",
  "child": [
   116
  ]
 },
 {
  "id": 116,
  "type": "card",
  "style": {
   "default": "card"
  },
  "x": 842,
  "y": 395,
  "text": "void update(int **p){ **p = 42; }\r\nint main(){\r\nint value=10;\r\nint *ptr = &value;\r\nupdate(&ptr;)\r\n}",
  "child": []
 },
 {
  "id": 117,
  "type": "card",
  "style": {
   "default": "card"
  },
  "x": 809,
  "y": 432,
  "text": "âŒ",
  "child": [
   118
  ]
 },
 {
  "id": 118,
  "type": "card",
  "style": {
   "default": "card"
  },
  "x": 841,
  "y": 283,
  "text": "This wont Update original variable\npass dereferenced pointer\n\n//x is a plain variable\nvoid update(int x){ x=42; }\n\nint main(){\nint value=10; int *ptr=&value;\nupdate(*ptr);\n}",
  "child": []
 }
]