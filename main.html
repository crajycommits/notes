<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Three Div Layout</title>
    <style>
        body {
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .top {
            background: #1F1F1F;
            border-bottom: 1px solid #707070;
            color: white;
            padding: 20px;
            text-align: center;
            flex: 0 0 20px;
        }
        .container{
            display: flex;
            flex: 1;
            height: calc(100vh - 60px);
        }
        .sidebar{
            background: #1F1F1F;
            width: 80px;
            padding: 20px;
            box-sizing: border-box;
            overflow: scroll;
        }
                /* WebKit browsers (Chrome, Edge, Safari) */
        ::-webkit-scrollbar {
          width: 12px;
          height: 12px;
        }

        ::-webkit-scrollbar-track {
          background: #121212;  /* Matches the dark background */
        }

        ::-webkit-scrollbar-thumb {
          background-color: #444;       /* Dark gray thumb */
          border-radius: 6px;
          border: 3px solid #121212;    /* Creates spacing around thumb */
        }

        ::-webkit-scrollbar-thumb:hover {
          background-color: #666;       /* Lighter gray on hover */
        }

        /* Firefox support */
        * {
          scrollbar-width: thin;
          scrollbar-color: #444 #121212;  /* thumb color, track color */
        }

        .main{
            background-color: #1F1F1F;
            flex: 1;
            padding: 20px;
            box-sizing: border-box;
            position: relative;
            overflow: hidden;
        }
        #draw_area{
            background: #1F1F1F;
            box-sizing: border-box;
            position: relative;
            display: flex;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        #anchor{
            width: 60px;
            height: 60px;
            background: rgb(191, 187, 187);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            opacity: .5;
            z-index: 98;
        }
        

        .bubble {
        position: relative;
        white-space: pre-wrap;
        border-radius: 0px;
        padding: 0px 0px;
        background: none;
        color: #9CDCFE;
        //font-family: 'Comic Sans MS', cursive;
        font-family: consolas;
        font-size: 8px;
        z-index: 79;
        }
        .goto {
        display: inline-block;
        background-color: #007BFF; /* Default blue */
        color: white;
        padding: 1px 1px;
        font-size: 20px;
        border-radius: 5px;
        cursor: pointer;
        text-align: center;
        user-select: none;
        transition: background-color 0.3s ease;
        }

        .goto:hover {
        background-color: #0056b3; /* Darker blue on hover */
        }
        .node{
            position: absolute;
        }
        .resize_node{
            white-space: pre;
            position: relative;
            resize: both;
            overflow: hidden;
            background: none;
        }
        .link {
            display: inline-block; /* Makes it behave like a box */
            padding: 5px 20px; /* Adds space inside the box */
            background-color: rgb(204, 186, 186); /* Blue background */
            color: black; /* White text */
            text-decoration: none; /* Removes underline */
            border-radius: 5px; /* Rounded corners */
            font-size: 10px;
            transition: background 0.3s ease;
            font-family: "Arial Black", "Arial Bold";
            z-index: 79;
        }
        .link:hover {
            background-color: #0056b3; /* Darker blue on hover */
        }
        .context-menu-target {
            padding: 20px;
            background-color: lightblue;
            border: 2px solid #007bff;
            text-align: center;
        }
    .context-menu {
        display: none;
        position: absolute;
        background: white;
        border: 1px solid #ccc;
        box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
        list-style: none;
        z-index: 100;
    }

    .context-menu li {
        padding: 8px 12px;
        cursor: pointer;
        list-style: none;
    }

    .context-menu li:hover {
        background: red;
    }
    #draw_area_pop {
        position: absolute;
        top: 33%;
        left: 33%;
        height: 200px; /* Or whatever height you need */
        width: 300px;  /* Or whatever width you need */
        background-color: lightgray; /* For visual clarity */
        visibility: hidden;
        border: 1px solid #ccc;
        box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
        z-index: 99;
    }
    #pop_text{
        width: 100%;
        height: 100%;
        overflow: scroll;
    }
    .img{
        padding: 0px;
        z-index: 77;
    }
    #delete-menu {
      position: absolute;
      background: white;
      border: 1px solid #ccc;
      padding: 5px;
      display: none;
      z-index: 1000;
    }
.goto-button {
  display: inline-block;
  background-color: #007bff;
  color: white;
  padding: 4px 10px;
  border: none;
  border-radius: 4px;
  font-size: 0.9em;
  cursor: pointer;
  text-decoration: none;
  transition: background-color 0.2s ease;
}

.goto-button:hover {
  background-color: #0056b3;
}
.hover-reveal-img {
  filter: brightness(40%);
  opacity: 0.7;
  transition: filter 0.3s ease, opacity 0.3s ease;
}

.hover-reveal-img:hover {
  filter: brightness(100%);
  opacity: 1;
}

    </style>
</head>
<script>
/*data = [
    {id: 1, type: "bubble", style: "bubble", x: 0, y: 0, title: ".", text: "snowflake is a \nsaas product\nsaas product\nsaas product\nsaas product"},
    {id: 2, type: "link", style: "link", x: 40, y: 100,  title: ".", href: "www.google.com", text: "google"},
    {id: 3, type: "img", style: "img", x: 80, y: 100,  title: ".", name: "chrome"},
    {id: 4, type: "img", style: "img", x: 80, y: 400,  title: ".", name: "download"},
    {id: 5, type: "bubble", style: "bubble", x: 0, y: 0,  title: ".", text: "dbt is a \nsaas         product\nsaas product\nsaas product\nsaas product"},
        
]*/

data=[]
g_file_name = null
function loadData(){
    data_input = document.getElementById('FileInput');
        const file = data_input.files[0];
        g_file_name = file.name
        if (!file) {
        alert("No file selected.")
        return;
        }
        const reader = new FileReader();
        reader.onload = function (event) {
        try {
            data = JSON.parse(event.target.result);
            //data = JSON.stringify(json, null, 2);
            //console.log(data)
        } catch (e) {
            console.log("Error parsing JSON: " + e.message)
        }
        };
        reader.readAsText(file);
}
images = {}
g_image_loaded = false
async function loadImages() {
  const input = document.getElementById('image-input');
  if (!input.files || input.files.length === 0) {
    alert('No files are selected');
    return;
  }

  const imageLoadPromises = [];

  for (let i = 0; i < input.files.length; i++) {
    const file = input.files[i];

    const loadPromise = new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = function (e) {
        const nameWithoutExt = file.name.replace(/\.[^/.]+$/, "");
        images[nameWithoutExt] = e.target.result;
        resolve(); // notify this image is done
      };
      reader.onerror = reject;
      reader.readAsDataURL(file);
    });

    imageLoadPromises.push(loadPromise);
  }

  // Wait for all FileReaders to finish
  await Promise.all(imageLoadPromises);

  // Now it's safe to load the sidebar
  loadSideBar();
  g_image_loaded=true
}


function resizeImage(img, maxWidth = 40, maxHeight = 40, quality = 1) {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');

  let { width, height } = img;

  if (width > height) {
    if (width > maxWidth) {
      height *= maxWidth / width;
      width = maxWidth;
    }
  } else {
    if (height > maxHeight) {
      width *= maxHeight / height;
      height = maxHeight;
    }
  }

  canvas.width = width;
  canvas.height = height;

  ctx.drawImage(img, 0, 0, width, height);

  return new Promise((resolve) => {
    canvas.toBlob(
      (blob) => resolve(blob),
      'image/jpeg',
      quality
    );
  });
}

function waitForImageLoad(img) {
  return new Promise((resolve, reject) => {
    if (img.complete) {
      resolve(img);
    } else {
      img.onload = () => resolve(img);
      img.onerror = (err) => reject(err);
    }
  });
}

g_clicked_sidebar_img_id = null
g_clicked_sidebar_div = null
g_clicked_key = null
async function loadSideBar(){
    console.log('side bar...')
    e = document.getElementById('sidebar')
    for (const [key, value] of Object.entries(images)) {
    img = document.createElement('img')
    img.src = value
    await waitForImageLoad(img);
    console.log(img);                     // Should be an <img> element
    console.log(img instanceof HTMLImageElement); // Should be true
    console.log(img.complete);  
    const d = document.createElement('div')
    try{
    resized_img = document.createElement('img')
    const blob = await resizeImage(img)
    const url = URL.createObjectURL(blob);
    resized_img.src = url
    d.id  = "sidebar_div_" + key
    resized_img.id = "sidebar_img_" + key
    resized_img.className = 'hover-reveal-img';
    resized_img.addEventListener("click", function () {
    g_clicked_key = key
    if (g_clicked_sidebar_img_id == this.id) // click same image
    {   
        g_clicked_sidebar_div = document.getElementById("sidebar_div_" + this.id.split('_').pop())
        alert(g_clicked_sidebar_div.style.border)
        if (g_clicked_sidebar_div.style.border == "") {g_clicked_sidebar_div.style.border = "thin solid black";}
        else {g_clicked_sidebar_div.style.border = ""}
    }
    else{
        if ( g_clicked_sidebar_div != null ) g_clicked_sidebar_div.style.border = ""
        g_clicked_sidebar_div = document.getElementById("sidebar_div_" + this.id.split('_').pop())
        g_clicked_sidebar_div.style.border = "thin solid black";
    }
    g_clicked_sidebar_img_id = this.id
    });
    }
    catch(err){
        console.log(err)
    }
    
    d.appendChild(resized_img)
    e.appendChild(d)
    }
}

function getLocalTimeStamp(){
    const now = new Date()
    return now.getFullYear().toString()+
    String(now.getMonth()+1).padStart(2, '0')+
    String(now.getDate()+1).padStart(2, '0')+
    String(now.getHours()+1).padStart(2, '0')+
    String(now.getMinutes()+1).padStart(2, '0')+
    String(now.getSeconds()+1).padStart(2, '0')

}

function downloadJSON() {
    // Sample JSON data
    //const data = {name: "Alice",age: 30,city: "New York"};

    // Convert to JSON string
    const jsonStr = JSON.stringify(data, null, 2); // Pretty print with 2 spaces

    // Create a Blob from the JSON string
    const blob = new Blob([jsonStr], { type: "application/json" });

    // Create a link element
    const link = document.createElement("a");

    // Set the URL for the Blob
    link.href = URL.createObjectURL(blob);
    new Date().toISOString().replace(/[-T:Z.]/g, '').slice(0,14)
    // link.download = g_file_name.split('.')[0] + getLocalTimeStamp() + '.' + g_file_name.split('.')[1] ; // File name
    if ( g_file_name == null ){ g_file_name = 'download.json'}
    let prefix = g_file_name.split('.')[0]
    let suffix = g_file_name.split('.')[1]
    let prefix_file = prefix.split('_')[0]
    let version = prefix.split('_')[1] ? parseInt(g_file_name.split('_')[1]) + 1 : 0
    link.download = prefix_file + '_' + version  + '.' + suffix ; // File name

    // Append link to body and trigger click
    document.body.appendChild(link);
    link.click();

    // Clean up
    document.body.removeChild(link);
}


const observer = new ResizeObserver(entries =>{
    for (let entry of entries){
        const element = entry.target
        parent_id = element.getAttribute("parent_id")
        console.log('content rect', entry.contentRect)
        const currentWidth = element.offsetWidth;
        const currentHeight = element.offsetHeight;
        console.log('width', currentWidth)
        console.log('height', currentHeight)
        setNodeHeight(element, parent_id, currentHeight);
        setNodeWidth(element, parent_id, currentWidth)
    }
})

/* depreceated in favor of observer
function handleResize(event)
{
    const element = event.target;
    console.log(element)
    if (event.target.getAttribute("item_sub_type") !=  "resizer"){return}
    parent_id = element.getAttribute("parent_id")

    data.forEach(item => {
        if (item.id == parent_id){
            if ( "maximize" in item ){ delete item.maximize}
        }
    });
    // Code to be executed when the window is resized
    node = document.getElementById(parent_id)
    const currentWidth = element.offsetWidth;
    const currentHeight = element.offsetHeight;
    setNodeHeight(element, parent_id, currentHeight);
    setNodeWidth(element, parent_id, currentWidth)
    console.log('resizer width on resize:', currentWidth); // Or use the width as needed
    console.log('resizer height on resize:', currentHeight); // Or use the width as needed

}*/

/* depreceated in favor of observer
function makeResizable(element){
    
    element.addEventListener('mouseup', handleResize);
}*/

function showBubbleText(show, text, bubble_obj){
    if (show){ setBubbleData(bubble_obj,  text ) } 
    else { setBubbleData(bubble_obj,  text.replace(/./g, 'x')) } 
}

function toggleBubbleText(bubble_obj, parent_id){
    let currentItem = null
    let currentText = ''
    let show = false
    data.forEach(item=>{
        if (item.id == parent_id){
            currentItem = item
            currentText = item.text
            if ("show" in item){
                item.show = !(item.show)
                show = item.show
            }
            else{
                item.show = false
                show = item.show
            }
        }
    })
    showBubbleText(show, currentText, bubble_obj)
}

function maximizeBubble(resizer_obj){
    // Reset styles
    resizer_obj.style.resize = "none";
    resizer_obj.style.whiteSpace = "pre"; // Preserve line breaks and spacing
    resizer_obj.style.overflow = "visible"; // Show content beyond box
    //resizer_obj.style.position = "static"; // Let it expand naturally if in flow
    resizer_obj.style.width = "auto";
    resizer_obj.style.height = "auto";
    resizer_obj.style.maxWidth = "50vw";
    resizer_obj.style.maxHeight = "50vh";
    observer.unobserve(resizer_obj);
}

function minimizeBubble(resizer_obj, width, height){
        resizer_obj.style.resize = "both";
        resizer_obj.style.whiteSpace = "pre"; // Preserve line breaks and spacing
        resizer_obj.style.removeProperty("overflow");
        resizer_obj.style.removeProperty("position");
        resizer_obj.style.removeProperty("max-width");
        resizer_obj.style.removeProperty("max-height");
        resizer_obj.style.height = height + "px"
        resizer_obj.style.width = width + "px"
        observer.observe(resizer_obj);
}

function handleBubbleContext(text, bubble_obj, target_id){
    console.log(text, bubble_obj, target_id)
    if (text=="editText"){
        console.log("at handleBubbleContext")
        msg = ''
        data.forEach(item=>{ if(item.id == target_id ) { 
            msg = item.text;
        }
        })
        showpop({type: "bubble", id: target_id, action: text, obj: bubble_obj, pop_text: msg})
    }
    if (text == "maximize") {
        resizer_obj = bubble_obj.closest('[item_sub_type="resizer"]');
        maximizeBubble(resizer_obj);
    }
    if (text == "minimize") {
        let width = height = 0;
        data.forEach(item=>{ if(item.id == target_id ) { 
            width = item.width; height = item.height
        }
        })
        console.log(width,height)
        resizer_obj = bubble_obj.closest('[item_sub_type="resizer"]');
        // Reset styles
        minimizeBubble(resizer_obj, width, height)
    }
    if (text=="editStyle"){
        custom_style_arr = [] // work around to access custom_style inside the block
        data.forEach(item=>{ if(item.id == target_id && "style" in item ) { 
            let stl = item.style; 
            const { default: _omit, ...custom_style } = item.style 
            console.log(custom_style)
            custom_style_arr.push(custom_style)
            }
        })
        custom_style = custom_style_arr.pop()
        if ( custom_style !== undefined && Object.keys(custom_style).length === 0 ){ msg = '{"font-size": "16px"}' } else { msg = JSON.stringify(custom_style)}
        showpop({type: "bubble", id: target_id, action: text, obj: bubble_obj, pop_text: msg })
    }
    if (text=="toggleView"){
        toggleBubbleText(bubble_obj, target_id)
    }
}

function getMaxID(){
        let max_id = -1
        data.forEach( d=> {
            max_id = d.id > max_id ? d.id : max_id
        })
        return max_id + 1
}
function handleHandleContext(text, obj, target_id){
    if (text == "delete"){
        console.log(obj, target_id)
        let idToRemove = obj.getAttribute("parent_id")
        const exists = data.some(item => item.id == idToRemove);
        console.log(exists)
        if (exists){
        const index = data.findIndex(item => item.id == idToRemove);
        console.log(index)
        console.log(data)
        if (index !== -1) {data.splice(index, 1)}
        console.log(data)
        e = document.getElementById(idToRemove)
        e.remove()
        }
    }
    if (text == "addTag"){
        let msg = ''
        data.forEach(item=>{if(item.id == target_id){ if("tag" in item){ msg = item.tag.join() } }})
        showpop({type: "handle", id: target_id, action: text, obj: obj, pop_text: msg })
    }
}
function handleDrawAreaContext(text, obj, target_id){
    if (text == "addBubble"){ 
        let max_id = getMaxID()
        let x = -global_x_moves
        let y = -global_y_moves
        console.log(global_x_moves)
        console.log(global_y_moves)
        new_bubble = {id: max_id, type: "bubble", style: {"default": "bubble"}, x: x, y: y, title: ".", text: "i am new bubble"}
        data.push(new_bubble)
        createNodes(getNodeParent(),[new_bubble])
    }
    if (text == "addLink"){
        let max_id = getMaxID()
        let x = -global_x_moves
        let y = -global_y_moves
        console.log(global_x_moves)
        console.log(global_y_moves)
        let link  = prompt("Enter Link");
        let link_text = prompt("Enter text");
        new_link = {id: max_id, type: "link", style: {"default": "link"}, x: x, y: y, title: ".", href: link,  text: link_text}
        data.push(new_link)
        createNodes(getNodeParent(),[new_link])
    }
    if (text == "addImage"){
        let max_id = getMaxID()
        let x = -global_x_moves
        let y = -global_y_moves
        let link  = prompt("Enter image name", g_clicked_key);
        let img = link
        new_img = {id: max_id, type: "img", style: {"default": "img"}, x: x, y: y, title: ".", name: img}
        data.push(new_img)
        createNodes(getNodeParent(),[new_img])
    }
    if (text == "addGoto"){
        let max_id = getMaxID()
        let x = -global_x_moves
        let y = -global_y_moves
        let name  = prompt("Enter name");
        let id = prompt("Enter Id")
        if (parseInt(id) === null || Number.isNaN(parseInt(id))) {alert("Value is null or NaN");return}
        new_goto = {id: max_id, type: "goto", style: {"default": "goto"}, x: x, y: y, title: ".", text: name, gotoid: id}
        data.push(new_goto)
        createNodes(getNodeParent(),[new_goto])
    }
}

function setNodeWidth(e, id, w = ''){
    parent = getNodeParent()
        data.forEach(item => {
            if (item.id == id){
                if (w==''){
                    if ( "width" in item ){ delete item.width}
                    //e.style.width = ''
                } else {
                    item.width = w
                    //e.style.width = item.width + "px"
                }
            }
        });
}

function setNodeHeight(e, id, h = ''){
    parent = getNodeParent()
        data.forEach(item => {
            if (item.id == id){
                if ( h == ''){
                    if ( "height" in item ){ delete item.height}
                    //e.style.height = ''
                }
                else {
                item.height = h
                //e.style.height = item.height + "px"
                }
            }
        });
}

function searchTag(tag){
    let res = []
    data.forEach(item=>{
        if ("tag" in item && tag.split(',').every(e=>item.tag.includes(e))){
            res.push(item.id)
        }
    })
    if (res.length>0){alert(res.join('\n'))}
}

g_make_context_flag=false
function makeContext(element){    
    
    let list_items = null
    // Show context menu on right-click
    element.addEventListener("contextmenu", (event) => {
        event.preventDefault(); // Prevent default right-click menu
        event.stopPropagation(); // Prevent default right-click menu
        console.log("event listener")
        type = element.getAttribute("item_sub_type")
        console.log(type)
        if (g_make_context_flag) return
        g_make_context_flag = true
        console.log(event.target)
        if (type == "bubble"){ list_items = createBubbleContext(event.target) }
        if (type == "draw_area"){ list_items = createDrawAreaContext(event.target) }
        if (type == "handle"){ list_items = createHandleContext(event.target) }
        list_items.id = "context_menu_list"
        document.getElementById("contextMenu").appendChild(list_items)
        
        const parentRect = getNodeParent().getBoundingClientRect()
        startX = event.pageX - parentRect.left
        startY = event.pageY - parentRect.top
        contextMenu.style.left = `${startX}px`;
        contextMenu.style.top = `${startY}px`;
        contextMenu.style.display = "block";
        console.log(g_make_context_flag)
    });
    // Hide context menu when clicking elsewhere
    document.addEventListener("click", () => {
       if (g_make_context_flag) {
        let list_items = document.getElementById("context_menu_list")
        console.log(document.getElementById("contextMenu"), list_items)
        document.getElementById("contextMenu").removeChild(list_items)
        list_items.remove()
    }
       g_make_context_flag = false
       contextMenu.style.display = "none";
    });
}

g_last_dragged_e = null
function overrideDraggableIpad(element){
    // maximize section
    if (element.getAttribute("item_type") === 'node' && element.querySelector('[item_sub_type="bubble"]')){
        const resizerElement = element.querySelector('[item_sub_type="resizer"]');
        const bubbleElement = element.querySelector('[item_sub_type="bubble"]');
        const parentId = resizerElement.getAttribute("parent_id");
        let width = null;
        let height = null;
        let current_item = null;
        data.forEach(item=>{ if(item.id == parentId ) { current_item = item; width = item.width; height = item.height } })
        console.log(current_item,width,height,resizerElement,bubbleElement,parentId)
        if ( "_max" in current_item && current_item._max){ 
            minimizeBubble(resizerElement, width, height)
            bubbleElement.style.backgroundColor = ""
            element.style.zIndex = "";
            current_item._max=false
        } else {
            maximizeBubble(resizerElement)
            element.style.zIndex = 80;
            bubbleElement.style.backgroundColor = "#1f1f1f"
            current_item._max=true
        }
    }
}
function makeDraggable(element, parent, handle = null) {
    const dragTarget = handle || element;
    element.style.position = 'absolute';
    dragTarget.style.cursor = 'move';

    let offsetX, offsetY, isDragging = false;
    let startX = 0, startY = 0;

    function startDrag(x, y) {
        console.log(element)
        if(isIPad() && element.getAttribute("item_type") === 'node'){
            overrideDraggableIpad(element)
            return
        }
        const parentRect = parent.getBoundingClientRect();
        const elemRect = element.getBoundingClientRect();
        offsetX = x - elemRect.left;
        offsetY = y - elemRect.top;
        startX = elemRect.left - parentRect.left;
        startY = elemRect.top - parentRect.top;
        isDragging = true;
        element.style.zIndex = 1000;
    }

    function dragMove(x, y) {
        if (!isDragging) return;
        const parentRect = parent.getBoundingClientRect();
        const newX = x - parentRect.left - offsetX;
        const newY = y - parentRect.top - offsetY;
        element.style.left = newX + 'px';
        element.style.top = newY + 'px';
    }

    function endDrag() {
        if (!isDragging) return;
        isDragging = false;
        element.style.zIndex = '';
        const parentRect = parent.getBoundingClientRect();
        const elemRect = element.getBoundingClientRect();
        const endX = elemRect.left - parentRect.left;
        const endY = elemRect.top - parentRect.top;
        const deltaX = Math.round(endX - startX);
        const deltaY = Math.round(endY - startY);
        if (element.id === "anchor") {
            resetAnchorAndMoveNodes(element, parent, deltaX, deltaY);
        } else if (element.id && element.getAttribute("item_type") === 'node') {
            updateNodePosition(element.id, deltaX, deltaY);
        }
    }

    // --- MOUSE EVENTS ---
    dragTarget.addEventListener('mousedown', function (e) {
        if (e.button === 2) return; // Right-click
        startDrag(e.clientX, e.clientY);
        e.preventDefault();
        e.stopPropagation();
    });

    document.addEventListener('mousemove', function (e) {
        dragMove(e.clientX, e.clientY);
    });

    document.addEventListener('mouseup', function () {
        endDrag();
    });

    // --- TOUCH EVENTS ---
    dragTarget.addEventListener('touchstart', function (e) {
        const touch = e.touches[0];
        startDrag(touch.clientX, touch.clientY);
        e.preventDefault();
        e.stopPropagation();
    }, { passive: false });

    document.addEventListener('touchmove', function (e) {
        if (!isDragging) return;
        const touch = e.touches[0];
        dragMove(touch.clientX, touch.clientY);
        e.preventDefault();
    }, { passive: false });

    document.addEventListener('touchend', function () {
        endDrag();
    });
}


    global_x_moves = 0 
    global_y_moves = 0

    g_global_moves = []
    function goToNode(id){
        id = parseInt(id)
        if ( id == -1){
            goBack()
            return
        }
        if ( ! ( data.map(d=>d.id).includes(id) ) ){

            alert("id not found:"+id)
            return
        }
        move_to_x = null
        move_to_y = null
        g_global_moves.push([global_x_moves, global_y_moves])
        data.forEach(item=>{
            if ( item.id == id ){
                move_to_x = item.x
                move_to_y = item.y
            }
        })
        if ( move_to_x == null ){return}
        global_x_moves = - move_to_x
        global_y_moves = -  move_to_y 
        data.forEach(item=>{
            item.calculatedX = item.x + global_x_moves
            item.calculatedY = item.y + global_y_moves
            console.log(item, global_x_moves, item.x)
            setNodePosition(item.id)
        })
    }

    function callGoToNode(id=null){
        console.log("goto",id)
        if (id==null){ goToNode(document.getElementById("input_goto").value) }
        else { goToNode(id) }
    }

    function goBack(){
        if (g_global_moves.length>0){
            let xy = g_global_moves.pop()
            let move_to_x = xy[0]
            let move_to_y = xy [1]
            global_x_moves = move_to_x
            global_y_moves = move_to_y
            data.forEach(item=>{
                item.calculatedX = item.x + global_x_moves
                item.calculatedY = item.y + global_y_moves
                setNodePosition(item.id)
            })
        }
        else {
            // do nothing
        }
    }

    function resetAnchorAndMoveNodes(anchor, parent, x, y){
        global_x_moves += x 
        global_y_moves += y
        shiftNodePosition(x, y)
        setPositionByPercentage(anchor, 50, 50, parent)
    }

    function getNodeParent(){
        return document.querySelector('#draw_area')
    }

    function setNodePosition(id){
        parent = getNodeParent()
        data.forEach(item => {
            if (item.id == id){
                div = document.getElementById(id)
                if (item.calculatedX + div.clientWidth < 0 || item.calculatedX > parent.clientWidth || item.calculatedY + div.clientHeight < 0 || item.calculatedY > parent.clientHeight)
                    {div.style.visibility = "hidden"}
                else
                    {div.style.visibility = "visible"}
                setPositionByCoords(document.getElementById(id), item.calculatedX, item.calculatedY, parent)
            }
        });
    }

    function updateNodePosition(id, x, y){
        data.forEach(item =>{
            if (item.id == id){
                item.x += x
                item.y += y
                item.calculatedX += x
                item.calculatedY += y
                
                setNodePosition(id)
            }
        })
    }

    function shiftNodePosition(shift_x = 0, shift_y = 0){
        parent = getNodeParent()
        data.forEach(item => {
            const id = item.id
            const div = document.getElementById(id)
            if (div) {
                const pos = getPosition(div, parent)
                item.calculatedX = pos.x + shift_x
                item.calculatedY = pos.y + shift_y
                setNodePosition(id)
            }
        })
    }

    function setPositionByCoords(element, x, y, parent){
        if (parent){
            element.style.position = 'absolute'
            element.style.left = x + 'px'
            element.style.top = y + 'px'
        } else {
            element.style.left = x + 'px'
            element.style.top = y + 'px'
        }
    }

    function setPositionByPercentage(element, x , y, parent){
        if (parent){
            element.style.position = 'absolute'
            element.style.left = x + '%'
            element.style.top = y + '%'
        } else {
            element.style.left = x + '%'
            element.style.top = y + '%'
        }
    }

    function getPosition(element, parent){
        const elemRect = element.getBoundingClientRect()
        const parentRect = parent.getBoundingClientRect()
        const pos = {
            x: Math.round(elemRect.left - parentRect.left),
            y: Math.round(elemRect.top - parentRect.top),
        }
        return pos
    }
    function createBubbleContext(t){
        options = ["editText", "toggleView", "editStyle", "maximize", "minimize"]
        return fillContextOptions(options, t)
    }
    function createDrawAreaContext(t){
        options = ["addBubble", "addLink", "addImage", "addGoto"]
        return fillContextOptions(options, t)
    }
    function createHandleContext(t){
        options = ["delete", "addTag"]
        return fillContextOptions(options, t)
    }
    function fillContextOptions(options, t){
        u = document.createElement("div")
        options.forEach(item => {
            l = document.createElement("div")
            l.textContent = item
            l.addEventListener('click', function() {
                console.log(this,t)
                if (t.getAttribute("item_sub_type") == "bubble"){handleBubbleContext(this.textContent,t, t.getAttribute("parent_id"))}
                if (t.getAttribute("item_sub_type") == "draw_area"){handleDrawAreaContext(this.textContent,t, t.getAttribute("parent_id"))}
                if (t.getAttribute("item_sub_type") == "handle"){handleHandleContext(this.textContent,t, t.getAttribute("parent_id"))}
            });
            u.appendChild(l)
        })
        return u
    }
    function createHandle(title, parent_id){
        handle = document.createElement("div")
        handle.textContent = title ? title : '.'
        handle.setAttribute("item_sub_type", "handle");
        handle.setAttribute("parent_id", parent_id);
        makeContext(handle)
        return handle
    }
    function applyStyle(data, e){
        if ("style" in data){
            Object.entries(data.style).forEach(([key,value])=>{
                if (key != "default"){
                    console.log(e,key,value)
                    e.style[key] = value
                }
            })
        }
    }
    function isIPad() {
    // For newer iPads running iPadOS (which report as Mac)
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
    const isMac = navigator.platform === 'MacIntel';
    const hasTouch = navigator.maxTouchPoints > 1;
    return isIOS || (isMac && hasTouch);
    }
    function decodeHtmlEntity(entity) {
    const txt = document.createElement("textarea");
    txt.innerHTML = entity;
    return txt.value;
    }
    function createGoto(data, parent_id){
        handle = createHandle(data.title, parent_id)
        const new_element = document.createElement('div')
        new_element.innerHTML = data.text
        new_element.style.position = 'relative'
        new_element.setAttribute("item_sub_type", "goto");
        new_element.setAttribute("parent_id", parent_id);
        new_element.classList.add(data.style.default);
        applyStyle(data, new_element)
        new_element.onclick=() => callGoToNode(data.gotoid);
        return {handle: handle, element: new_element}
    }
    function createImg(data, parent_id){
        handle = createHandle(data.title, parent_id)
        const new_element = document.createElement('img')
        new_element.src = images[data.name]
        new_element.style.position = 'relative'
        new_element.setAttribute("item_sub_type", "img");
        new_element.setAttribute("parent_id", parent_id);
        new_element.setAttribute("alt", data.name)
        new_element.classList.add(data.style.default);
        applyStyle(data, new_element)
        return {handle: handle, element: new_element}
    }
    function createLink(data, parent_id){
        handle = createHandle(data.title, parent_id)
        const new_element = document.createElement('a')
        new_element.href = data.href
        new_element.textContent = data.text
        new_element.target = '_blank'; // Open in new tab
        new_element.style.position = 'relative'
        new_element.setAttribute("item_sub_type", "link");
        new_element.setAttribute("parent_id", parent_id);
        new_element.classList.add(data.style.default);
        applyStyle(data, new_element)
        return {handle: handle, element: new_element}
    }

   /*function setBubbleData(outputDiv, encodedText){
        encodedText = decodeHtmlEntity(encodedText)
        outputDiv.innerHTML = ''
        //const regex = /\[size=(\d+)\]([\s\S]*?)\[\/size\]/g;
        //this helps to escape raw data like \[size=24]abc\[/size\  ]
         const regex = /(?<!\\)\[(size|color)=([^\]]+)\]([\s\S]*?)\[\/\1\]/g;
        let lastIndex = 0
        let match
        console.log(outputDiv, encodedText)
        while( ( match = regex.exec(encodedText)) ){
            if (match.index > lastIndex ){
                const before = encodedText.slice(lastIndex, match.index)
                console.log(before)
                outputDiv.appendChild(document.createTextNode(before))
            }

        // Create a span for the matched tag content
        const span = document.createElement('span');

        if (match[1] === 'size') {
          // match[2] is font size (number)
          span.style.fontSize = match[2] + 'px';
        } else if (match[1] === 'color') {
          // match[2] is color value (e.g. 'red', '#ff0000')
          span.style.color = match[2];
        }

        span.textContent = match[3];

            //span does nothing on right click but pops up bubble edit menu then on rightclick doess nothing causing confusion
            span.addEventListener("contextmenu", function(e){
                e.preventDefault()
                e.stopPropagation()
            })
            console.log(span)
            outputDiv.appendChild(span)


            lastIndex = regex.lastIndex
        }

        if (lastIndex < encodedText.length){
            outputDiv.appendChild(document.createTextNode(encodedText.slice(lastIndex)))
            console.log(encodedText.slice(lastIndex))
        }
        console.log(outputDiv)
        return 
    }*/
function setBubbleData(outputDiv, encodedText) {
  encodedText = decodeHtmlEntity(encodedText);
  outputDiv.innerHTML = '';

function parseSegment(text) {
  // Replace [s=...] tags with font-size spans
  text = text.replace(/\[s=([^\]]+)\]([\s\S]*?)\[\/s\]/g, (_, size, content) => {
    return `<span style="font-size: ${size}px;">${content}</span>`;
  });

  // Replace [c=...] tags with color spans
  text = text.replace(/\[c=([^\]]+)\]([\s\S]*?)\[\/c\]/g, (_, color, content) => {
    return `<span style="color: ${color};">${content}</span>`;
  });

  // Replace [g=...] tags with clickable span styled as button
  text = text.replace(/\[g=(\d+)\]([\s\S]*?)\[\/g\]/g, (_, nodeId, content) => {
    return `<span class="goto-button" onclick="callGoToNode(${nodeId})">${content}</span>`;
  });

  return text;
}


  // Add context menu listener on the entire output div
  outputDiv.addEventListener('contextmenu', e => {
    e.preventDefault();
    e.stopPropagation();
    // You can customize what happens on right-click here
    console.log('Context menu triggered on bubble');
    // For example: show a custom menu
  });

  outputDiv.innerHTML=parseSegment(encodedText);
}

    function setBubbleData_old(outputDiv, encodedText) {
      encodedText = decodeHtmlEntity(encodedText);
      outputDiv.innerHTML = '';

      function parseSegment(text) {
        const container = document.createDocumentFragment();

        const regex = /(?<!\\)\[(size|color)=([^\]]+)\]([\s\S]*?)\[\/\1\]/g;
        let lastIndex = 0;
        let match;

        while ((match = regex.exec(text))) {
          // Text before the tag
          if (match.index > lastIndex) {
            container.appendChild(document.createTextNode(text.slice(lastIndex, match.index)));
          }

          // Create a span with style according to tag
          const span = document.createElement('span');
          if (match[1] === 'size') {
            span.style.fontSize = match[2] + 'px';
          } else if (match[1] === 'color') {
            span.style.color = match[2];
          }

          // Recursively parse inner content to support nested tags
          span.appendChild(parseSegment(match[3]));

          // Prevent context menu confusion
          span.addEventListener('contextmenu', e => {
            e.preventDefault();
            e.stopPropagation();
          });

          container.appendChild(span);
          lastIndex = regex.lastIndex;
        }

        // Remaining text after last tag
        if (lastIndex < text.length) {
          container.appendChild(document.createTextNode(text.slice(lastIndex)));
        }

        return container;
      }

      outputDiv.appendChild(parseSegment(encodedText));
    }


    function createBubble(data, parent_id){
        handle = createHandle(data.title, parent_id)
        const new_element = document.createElement('div')
        //new_element.textContent = decodeHtmlEntity(data.text)
        //setBubbleData( new_element, 'Hello [size=24] abc [/size] def ghi [size=24] def [/size]' )
        //setBubbleData( new_element, data.text )
        if ("show" in data){ showBubbleText(data.show, data.text, new_element) }
        else { showBubbleText(true, data.text, new_element) }
        new_element.style.position = 'relative'
        new_element.setAttribute("item_sub_type", "bubble");
        new_element.setAttribute("parent_id", parent_id);
        new_element.classList.add(data.style.default);
        applyStyle(data, new_element)
        // this is only for testing
        //applyRandomTextColor(new_element)
        new_element.onclick=makeContext(new_element)
        return {handle: handle, element: new_element}
    }

    function createNodes(parent, nodes){
        console.log(nodes)
        nodes.forEach(item=>{
            console.log(item)
            if (document.getElementById(item.id)){ alert('id already taken'); return }
            new_element = null
            container = null
            resize_node = null
            item.calculatedX = item.x + global_x_moves
            item.calculatedY = item.y + global_y_moves
            const node = document.createElement("div")
            node.id = item.id
            if (item.type == "bubble"){
            resize_node  = document.createElement("div")
            resize_node.setAttribute("item_sub_type", "resizer");
            resize_node.setAttribute("parent_id", node.id);
            resize_node.classList.add("resize_node")
            //makeResizable(resize_node)
            if (["height"] in item) { resize_node.style.height = item.height + "px" } else { resize_node.style.height = "200px" }
            if (["width"] in item) { resize_node.style.width = item.width + "px" } else { resize_node.style.width = "200px" }
            observer.observe(resize_node)
            container =  resize_node
            node.appendChild(resize_node)
            }
            else {
                container = node
            }
            

            node.classList.add('node');
            if (item.type == "bubble") { new_element = createBubble(item, item.id)}
            if (item.type == "link") { new_element = createLink(item, item.id)}
            if (item.type == "img") { new_element = createImg(item, item.id)}
            if (item.type == "goto") { new_element = createGoto(item, item.id)}
            handle = new_element['handle']
            new_element = new_element['element']
            node.setAttribute("item_type", "node");
            console.log(handle,new_element)
            if(handle){container.appendChild(handle)}
            container.appendChild(new_element)
            parent.appendChild(node)
            setNodePosition(node.id)
            makeDraggable(node, parent, handle)
        })
    }

    pop_holder = null
    function showpop(initiator){
        console.log("at showpop", initiator)
        pop_holder = initiator
        pop = document.getElementById("draw_area_pop")
        pop_text = document.getElementById("pop_text")
        pop_text.value = initiator.pop_text 
        pop.style.visibility="visible"
        
    }
    
    function get_pop_input(){
        txt = document.getElementById('pop_text').value
        console.log(txt)
        document.getElementById("draw_area_pop").style.visibility = "hidden"
        call_pop_initiator(txt)
    }
    function call_pop_initiator(txt){
        console.log("call_pop_initiator")
        if (txt != null && pop_holder.type == "bubble" && pop_holder.action == "editText" )
        {
            updateBubbleText(pop_holder.id, txt)
            
        }
        if (txt != null && pop_holder.action == "editStyle" )
        {
            try{
            console.log(txt)
            console.log(pop_holder.obj)
            json=JSON.parse(txt)
            id = pop_holder.id
            data.forEach(item => {
                if (id == item.id) {
                    
                    Object.entries(json).forEach(([key, value]) => {
                        console.log(key, value)
                        item['style'][key] = value
                    });
                applyStyle(item, pop_holder.obj)
                }
            });
            }
            catch(error)
            {
                console.log(txt)
                alert(error)
            }
        }
        if (pop_holder.type == "handle" && pop_holder.action == "addTag" ){
            if (txt != null && txt.trim() != ''){
                id = pop_holder.id
                console.log(txt, id)
                data.forEach(item => {
                    if (id == item.id) {
                        item['tag'] = txt.split(",")
                        }
                    });
            }
            else {
                user_confirm = confirm("delete tag ?")
                if (user_confirm) {
                    data.forEach(item => {
                        if (id == item.id && 'tag' in item) {
                            delete item.tag
                            }
                        });   
                }
            }
        }
    pop_holder = null
    }
    function updateBubbleText(id, txt){
        console.log('update bubble text', id, txt)
        data.forEach(item=>{
            if ( item.id == id ){ 
                item.text = txt; e=document.getElementById(id)
                //e.querySelectorAll('[item_sub_type="bubble"]')[0].textContent = decodeHtmlEntity(txt)
                let bubble = e.querySelectorAll('[item_sub_type="bubble"]')[0]
                setBubbleData(bubble, txt)
            }
        })
    }
    const textColors = [
      'primary-text',
      'secondary-text',
      'tertiary-text',
      'accent-text',
      'error-text',
      'success-text',
      'warning-text', 'text-color-1',  'text-color-2',  'text-color-3',  'text-color-4',  'text-color-5',
  'text-color-6',  'text-color-7',  'text-color-8',  'text-color-9',  'text-color-10',
  'text-color-11', 'text-color-12', 'text-color-13', 'text-color-14', 'text-color-15',
  'text-color-16', 'text-color-17', 'text-color-18', 'text-color-19', 'text-color-20'
    ];

    function applyRandomTextColor(element) {
      const randomClass = textColors[Math.floor(Math.random() * textColors.length)];
      element.classList.add(randomClass);
    }
</script>
<body>
    <div class="top"> Top Bar
        <button onclick="createNodes(getNodeParent(), data)">Add Element</button>
        <input type="file" id="image-input" accept="image/*" multiple style="display:none" onchange="loadImages()">
         <input type="file" id="FileInput" accept=".json" onchange="loadData()"/>
        <button onclick="document.getElementById('image-input').click()">Load images</button>
        <button onclick="downloadJSON()">download</button>
        <button onclick="callGoToNode(-1)">back</button>
        <input id="input_goto" placeholder="Enter Id(-1 back)"/>
    </div>
    <div class="container">
        <div class="sidebar" id = 'sidebar'>
        </div>
        <div class="main" id="draggable-main">
            <div id="draw_area" item_sub_type="draw_area">
                <div id = "draw_area_pop" item_sub_type="draw_area_pop">
                    <textarea id = "pop_text"></textarea>
                    <button onclick="get_pop_input()">submit</button>
                </div>
                <div id="contextMenu" class="context-menu">
                </div>
                <div id="anchor">
                </div>
            </div>
        </div>
    </div>
    <script>
        window.onload = function(){
            const anchor = document.getElementById("anchor")
            const main = document.getElementById("draggable-main")
            const draw_area = document.getElementById("draw_area")
            makeDraggable(anchor, draw_area)
            makeContext(draw_area)
            document.getElementById("input_goto").addEventListener('keydown', function(event){
                event.stopPropagation()
                if (event.key == 'Enter'){
                    callGoToNode( document.getElementById("input_goto").value.trim() )
                }
            })
        }   
    </script>
</body>
</html>
