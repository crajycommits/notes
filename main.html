<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Three Div Layout</title>
    <style>
        body {
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .top {
            background: #1F1F1F;
            border-bottom: 1px solid #707070;
            color: white;
            padding: 20px;
            text-align: center;
            flex: 0 0 20px;
        }
        .container{
            display: flex;
            flex: 1;
            height: calc(100vh - 60px);
        }
        .sidebar{
            background: #1F1F1F;
            width: 80px;
            padding: 20px;
            box-sizing: border-box;
            overflow: scroll;
        }
                /* WebKit browsers (Chrome, Edge, Safari) */
        ::-webkit-scrollbar {
          width: 12px;
          height: 12px;
        }

        ::-webkit-scrollbar-track {
          background: #121212;  /* Matches the dark background */
        }

        ::-webkit-scrollbar-thumb {
          background-color: #444;       /* Dark gray thumb */
          border-radius: 6px;
          border: 3px solid #121212;    /* Creates spacing around thumb */
        }

        ::-webkit-scrollbar-thumb:hover {
          background-color: #666;       /* Lighter gray on hover */
        }

        /* Firefox support */
        * {
          scrollbar-width: thin;
          scrollbar-color: #444 #121212;  /* thumb color, track color */
        }

        .main{
            background-color: #1F1F1F;
            flex: 1;
            padding: 20px;
            box-sizing: border-box;
            position: relative;
            overflow: hidden;
        }
        #draw_area{
            background: #1F1F1F;
            box-sizing: border-box;
            position: relative;
            display: flex;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        #anchor{
            width: 60px;
            height: 60px;
            background: rgb(191, 187, 187);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            opacity: .5;
        }
        .handle {
            color: #95B9DA;
            background: #1f1f1f
        }
        .bubble {
        position: relative;
        white-space: pre-wrap;
        border-radius: 0px;
        padding: 0px 0px;
        background: #1F1F1F;
        color: #9CDCFE;
        //font-family: 'Comic Sans MS', cursive;
        font-family: consolas;
        font-size: 8px;
        }
        .quiz{
        position: relative;
        white-space: pre-wrap;
        border-radius: 0px;
        padding: 2px 2px;
        background: #1F1F1F;
        color: #9CDCFE;
        //font-family: 'Comic Sans MS', cursive;
        font-family: consolas;
        font-size: 8px;
        }
        .quiz-box {
        margin: 20px;
        font-family: sans-serif;
        }
        .quiz-input {
            font-size: 8px;
            margin-top: 10px;
            padding: 8px;
            display: inline-block;
            min-width: 80px;
            margin-right: 5px;

            background-color: #2D2D30;
            color: #D16D9E;             /* Muted maroon-pinkish tone for subtle contrast */
            border: 1px solid #3C3C3C;
            border-radius: 4px;

            outline: none;
        }
        .quiz-option {
        margin-top: 10px;
        margin-bottom: 10px;
        padding: 8px;
        display: block;         /* Stack options vertically */
        border: 1px solid #ccc;
        border-radius: 4px;
        cursor: pointer;
        width: fit-content;
        }
        .quiz-hint {
            background-color: #2D2D30; /* Slightly lighter than your base background */
            border: 1px solid #3C3C3C; /* Subtle border for structure */
            color: #DCDCAA; /* A soft yellow often used for tips/hints in editors */
            font-style: italic;
        }
        .quiz-correct {
            background-color: #004d00; /* A dark green that fits dark themes */
            border: 1px solid #27ae60;
            color: #9CDCFE; /* Matches your overall font color */
        }
        .quiz-selected {
        border-color: #ec971f;     /* deeper orange */
        background-color: #3b2a1f;   /* subtle dark orange-brown highlight */
        }
        .quiz-controls {
        margin-top: 20px;
        }
        .quiz-button {
            padding: 10px 16px;
            margin-top: 12px;
            margin-right: 10px;
            border-radius: 8px;          /* rounded edges */
            border: none;                /* remove default border */
            background-color: #3a8ddb; /* bright blue */
            color: white;                /* white text */
            cursor: pointer;             /* pointer cursor on hover */
            transition: background-color 0.3s ease;
        }
        .quiz-incorrect {
            background-color: #3b1e1e; /* Dark muted red */
            border: 1px solid #e74c3c; /* Vibrant red accent */
            color: #9CDCFE;            /* Your standard font color */
        }
        .quiz-button:hover {
        background-color: #2c6cb1;  /* darker blue on hover */
        box-shadow: 0 4px 10px rgba(44, 108, 177, 0.7);        
        }

        .quiz-disabled {
        pointer-events: none;
        opacity: 0.6;
        }
        .goto {
        display: inline-block;
        background-color: #007BFF; /* Default blue */
        color: white;
        padding: 1px 1px;
        font-size: 20px;
        border-radius: 5px;
        cursor: pointer;
        text-align: center;
        user-select: none;
        transition: background-color 0.3s ease;
        }

        .goto:hover {
        background-color: #0056b3; /* Darker blue on hover */
        }
        .node{
            position: absolute;
        }
        .resize_node{
            white-space: pre;
            position: relative;
            resize: both;
            overflow: hidden;
            background: none;
        }
        .link {
            display: inline-block; /* Makes it behave like a box */
            padding: 5px 20px; /* Adds space inside the box */
            background-color: rgb(204, 186, 186); /* Blue background */
            color: black; /* White text */
            text-decoration: none; /* Removes underline */
            border-radius: 5px; /* Rounded corners */
            font-size: 10px;
            transition: background 0.3s ease;
            font-family: "Arial Black", "Arial Bold";
        }
        .link:hover {
            background-color: #0056b3; /* Darker blue on hover */
        }
        .context-menu-target {
            padding: 20px;
            background-color: lightblue;
            border: 2px solid #007bff;
            text-align: center;
        }
    .context-menu {
        display: none;
        position: absolute;
        background: white;
        border: 1px solid #ccc;
        box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
        list-style: none;
    }

    .context-menu li {
        padding: 8px 12px;
        cursor: pointer;
        list-style: none;
    }

    .context-menu li:hover {
        background: red;
    }
    #draw_area_pop {
        position: absolute;
        top: 33%;
        left: 33%;
        height: 200px; /* Or whatever height you need */
        width: 300px;  /* Or whatever width you need */
        background-color: lightgray; /* For visual clarity */
        visibility: hidden;
        border: 1px solid #ccc;
        box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
    }
    #pop_text{
        width: 100%;
        height: 100%;
        overflow: scroll;
    }
    .img{
        padding: 0px;
    }

.goto-button {
  display: inline-block;
  background-color: #007bff;
  color: white;
  padding: 4px 10px;
  border: none;
  border-radius: 4px;
  font-size: 0.9em;
  cursor: pointer;
  text-decoration: none;
  transition: background-color 0.2s ease;
}

.goto-button:hover {
  background-color: #0056b3;
}
.hover-reveal-img {
  filter: brightness(40%);
  opacity: 0.7;
  transition: filter 0.3s ease, opacity 0.3s ease;
}

.hover-reveal-img:hover {
  filter: brightness(100%);
  opacity: 1;
}
.inline-link {
    display: inline-block;
    background-color: #9CDCFE; /* Match overall background */
    color: #1F1F1F;            /* Match overall text color */
    text-decoration: none;
    border-radius: 2px;
    font-family: "Arial Black", "Arial Bold";
}


    </style>
</head>
<script>
/*data = [
    {id: 1, type: "bubble", style: "bubble", x: 0, y: 0, title: ".", text: "snowflake is a \nsaas product\nsaas product\nsaas product\nsaas product"},
    {id: 2, type: "link", style: "link", x: 40, y: 100,  title: ".", href: "www.google.com", text: "google"},
    {id: 3, type: "img", style: "img", x: 80, y: 100,  title: ".", name: "chrome"},
    {id: 4, type: "img", style: "img", x: 80, y: 400,  title: ".", name: "download"},
    {id: 5, type: "bubble", style: "bubble", x: 0, y: 0,  title: ".", text: "dbt is a \nsaas         product\nsaas product\nsaas product\nsaas product"},
        
]*/
const zIndices = { bubble: 79, quiz: 79, link: 79, img: 77, goto: 79, topSpot: 80 };

data=[]
g_file_name = null
function loadData(){
    data_input = document.getElementById('FileInput');
        const file = data_input.files[0];
        g_file_name = file.name
        if (!file) {
        alert("No file selected.")
        return;
        }
        const reader = new FileReader();
        reader.onload = function (event) {
        try {
            data = JSON.parse(event.target.result);
            //data = JSON.stringify(json, null, 2);
            //console.log(data)
        } catch (e) {
            console.log("Error parsing JSON: " + e.message)
        }
        };
        reader.readAsText(file);
}
images = {}
g_image_loaded = false
async function loadImages() {
  const input = document.getElementById('image-input');
  if (!input.files || input.files.length === 0) {
    alert('No files are selected');
    return;
  }

  const imageLoadPromises = [];

  for (let i = 0; i < input.files.length; i++) {
    const file = input.files[i];

    const loadPromise = new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = function (e) {
        const nameWithoutExt = file.name.replace(/\.[^/.]+$/, "");
        images[nameWithoutExt] = e.target.result;
        resolve(); // notify this image is done
      };
      reader.onerror = reject;
      reader.readAsDataURL(file);
    });

    imageLoadPromises.push(loadPromise);
  }

  // Wait for all FileReaders to finish
  await Promise.all(imageLoadPromises);

  // Now it's safe to load the sidebar
  loadSideBar();
  g_image_loaded=true
}


function resizeImage(img, maxWidth = 40, maxHeight = 40, quality = 1) {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');

  let { width, height } = img;

  if (width > height) {
    if (width > maxWidth) {
      height *= maxWidth / width;
      width = maxWidth;
    }
  } else {
    if (height > maxHeight) {
      width *= maxHeight / height;
      height = maxHeight;
    }
  }

  canvas.width = width;
  canvas.height = height;

  ctx.drawImage(img, 0, 0, width, height);

  return new Promise((resolve) => {
    canvas.toBlob(
      (blob) => resolve(blob),
      'image/jpeg',
      quality
    );
  });
}

function waitForImageLoad(img) {
  return new Promise((resolve, reject) => {
    if (img.complete) {
      resolve(img);
    } else {
      img.onload = () => resolve(img);
      img.onerror = (err) => reject(err);
    }
  });
}

g_clicked_sidebar_img_id = null
g_clicked_sidebar_div = null
g_clicked_key = null
async function loadSideBar(){
    console.log('side bar...')
    e = document.getElementById('sidebar')
    for (const [key, value] of Object.entries(images)) {
    img = document.createElement('img')
    img.src = value
    await waitForImageLoad(img);
    console.log(img);                     // Should be an <img> element
    console.log(img instanceof HTMLImageElement); // Should be true
    console.log(img.complete);  
    const d = document.createElement('div')
    try{
    resized_img = document.createElement('img')
    const blob = await resizeImage(img)
    const url = URL.createObjectURL(blob);
    resized_img.src = url
    d.id  = "sidebar_div_" + key
    resized_img.id = "sidebar_img_" + key
    resized_img.className = 'hover-reveal-img';
    resized_img.addEventListener("click", function () {
    g_clicked_key = key
    if (g_clicked_sidebar_img_id == this.id) // click same image
    {   
        g_clicked_sidebar_div = document.getElementById("sidebar_div_" + this.id.split('_').pop())
        alert(g_clicked_sidebar_div.style.border)
        if (g_clicked_sidebar_div.style.border == "") {g_clicked_sidebar_div.style.border = "thin solid black";}
        else {g_clicked_sidebar_div.style.border = ""}
    }
    else{
        if ( g_clicked_sidebar_div != null ) g_clicked_sidebar_div.style.border = ""
        g_clicked_sidebar_div = document.getElementById("sidebar_div_" + this.id.split('_').pop())
        g_clicked_sidebar_div.style.border = "thin solid black";
    }
    g_clicked_sidebar_img_id = this.id
    });
    }
    catch(err){
        console.log(err)
    }
    
    d.appendChild(resized_img)
    e.appendChild(d)
    }
}

function getLocalTimeStamp(){
    const now = new Date()
    return now.getFullYear().toString()+
    String(now.getMonth()+1).padStart(2, '0')+
    String(now.getDate()+1).padStart(2, '0')+
    String(now.getHours()+1).padStart(2, '0')+
    String(now.getMinutes()+1).padStart(2, '0')+
    String(now.getSeconds()+1).padStart(2, '0')

}

function downloadJSON() {
    // Sample JSON data
    //const data = {name: "Alice",age: 30,city: "New York"};

// Recursive function to remove _ keys
function removeUnderscoreKeys(obj) {
  if (Array.isArray(obj)) {
    return obj.map(removeUnderscoreKeys);
  } else if (obj !== null && typeof obj === 'object') {
    return Object.fromEntries(
      Object.entries(obj)
        .filter(([key]) => !key.startsWith('_'))
        .map(([key, value]) => [key, removeUnderscoreKeys(value)])
    );
  }
  return obj;
}

const cleanedData = removeUnderscoreKeys(data);

// Convert to JSON string with 1-space indentation
const jsonStr = JSON.stringify(cleanedData, null, 1); // Pretty print with 2 spaces

    // Create a Blob from the JSON string
    const blob = new Blob([jsonStr], { type: "application/json" });

    // Create a link element
    const link = document.createElement("a");

    // Set the URL for the Blob
    link.href = URL.createObjectURL(blob);
    new Date().toISOString().replace(/[-T:Z.]/g, '').slice(0,14)
    // link.download = g_file_name.split('.')[0] + getLocalTimeStamp() + '.' + g_file_name.split('.')[1] ; // File name
    if ( g_file_name == null ){ g_file_name = 'download.json'}
    let prefix = g_file_name.split('.')[0]
    let suffix = g_file_name.split('.')[1]
    let prefix_file = prefix.split('_')[0]
    let version = prefix.split('_')[1] ? parseInt(g_file_name.split('_')[1]) + 1 : 0
    link.download = prefix_file + '_' + version  + '.' + suffix ; // File name

    // Append link to body and trigger click
    document.body.appendChild(link);
    link.click();

    // Clean up
    document.body.removeChild(link);
}


const observer = new ResizeObserver(entries =>{
    for (let entry of entries){
        const element = entry.target
        parent_id = element.getAttribute("parent_id")
        parent_e = document.getElementById(parent_id)
        console.log('content rect', entry.contentRect)
        const currentWidth = element.offsetWidth;
        const currentHeight = element.offsetHeight;
        console.log('width', currentWidth)
        console.log('height', currentHeight)
        setNodeHeight(element, parent_id, currentHeight);
        setNodeWidth(element, parent_id, currentWidth)
        node_on_top(parent_e, parent_e.style.zIndex)
    }
})

/* depreceated in favor of observer
function handleResize(event)
{
    const element = event.target;
    console.log(element)
    if (event.target.getAttribute("item_sub_type") !=  "resizer"){return}
    parent_id = element.getAttribute("parent_id")

    data.forEach(item => {
        if (item.id == parent_id){
            if ( "maximize" in item ){ delete item.maximize}
        }
    });
    // Code to be executed when the window is resized
    node = document.getElementById(parent_id)
    const currentWidth = element.offsetWidth;
    const currentHeight = element.offsetHeight;
    setNodeHeight(element, parent_id, currentHeight);
    setNodeWidth(element, parent_id, currentWidth)
    console.log('resizer width on resize:', currentWidth); // Or use the width as needed
    console.log('resizer height on resize:', currentHeight); // Or use the width as needed

}*/

/* depreceated in favor of observer
function makeResizable(element){
    
    element.addEventListener('mouseup', handleResize);
}*/

function showBubbleText(show, text, bubble_obj){
    if (show){ featchCustomParsedData(bubble_obj,  text ) } 
    else { featchCustomParsedData(bubble_obj,  text.replace(/./g, 'x')) } 
}

function toggleBubbleText(bubble_obj, parent_id){
    let currentItem = null
    let currentText = ''
    let show = false
    data.forEach(item=>{
        if (item.id == parent_id){
            currentItem = item
            currentText = item.text
            if ("show" in item){
                item.show = !(item.show)
                show = item.show
            }
            else{
                item.show = false
                show = item.show
            }
        }
    })
    showBubbleText(show, currentText, bubble_obj)
}
function maximizequiz(resizer_obj){
    // Reset styles
    resizer_obj.style.resize = "none";
    resizer_obj.style.whiteSpace = "pre"; // Preserve line breaks and spacing
    resizer_obj.style.overflow = "visible"; // Show content beyond box
    //resizer_obj.style.position = "static"; // Let it expand naturally if in flow
    resizer_obj.style.width = "35vw";
    resizer_obj.style.height = "35vh";
    resizer_obj.style.maxWidth = "35vw";
    resizer_obj.style.maxHeight = "35vh";
    observer.unobserve(resizer_obj);
}

function minimizequiz(resizer_obj, width, height){
        resizer_obj.style.resize = "both";
        resizer_obj.style.whiteSpace = "pre"; // Preserve line breaks and spacing
        resizer_obj.style.removeProperty("overflow");
        resizer_obj.style.removeProperty("position");
        resizer_obj.style.removeProperty("max-width");
        resizer_obj.style.removeProperty("max-height");
        resizer_obj.style.height = height + "px"
        resizer_obj.style.width = width + "px"
        observer.observe(resizer_obj);
}
function maximizeBubble(resizer_obj){
    // Reset styles
    resizer_obj.style.resize = "none";
    resizer_obj.style.whiteSpace = "pre"; // Preserve line breaks and spacing
    resizer_obj.style.overflow = "visible"; // Show content beyond box
    //resizer_obj.style.position = "static"; // Let it expand naturally if in flow
    resizer_obj.style.width = "auto";
    resizer_obj.style.height = "auto";
    resizer_obj.style.maxWidth = "50vw";
    resizer_obj.style.maxHeight = "50vh";
    observer.unobserve(resizer_obj);
}

function minimizeBubble(resizer_obj, width, height){
        resizer_obj.style.resize = "both";
        resizer_obj.style.whiteSpace = "pre"; // Preserve line breaks and spacing
        resizer_obj.style.removeProperty("overflow");
        resizer_obj.style.removeProperty("position");
        resizer_obj.style.removeProperty("max-width");
        resizer_obj.style.removeProperty("max-height");
        resizer_obj.style.height = height + "px"
        resizer_obj.style.width = width + "px"
        observer.observe(resizer_obj);
}
function handleQuizContext(text, quiz_obj, target_id){
    if (text=="editText"){
        console.log("at handleQuizContext")
        msg = ''
        data.forEach(item=>{ if(item.id == target_id ) { 
            msg = JSON.stringify(item.text, null, 2);
        }
        })
        showpop({type: "quiz", id: target_id, action: text, obj: quiz_obj, pop_text: msg})
    }
}

function handleBubbleContext(text, bubble_obj, target_id){
    console.log(text, bubble_obj, target_id)
    if (text=="editText"){
        console.log("at handleBubbleContext")
        msg = ''
        data.forEach(item=>{ if(item.id == target_id ) { 
            msg = item.text;
        }
        })
        showpop({type: "bubble", id: target_id, action: text, obj: bubble_obj, pop_text: msg})
    }
    if (text == "maximize") {
        resizer_obj = bubble_obj.closest('[item_sub_type="resizer"]');
        maximizeBubble(resizer_obj);
    }
    if (text == "minimize") {
        let width = height = 0;
        data.forEach(item=>{ if(item.id == target_id ) { 
            width = item.width; height = item.height
        }
        })
        console.log(width,height)
        resizer_obj = bubble_obj.closest('[item_sub_type="resizer"]');
        // Reset styles
        minimizeBubble(resizer_obj, width, height)
    }
    if (text=="editStyle"){
        custom_style_arr = [] // work around to access custom_style inside the block
        data.forEach(item=>{ if(item.id == target_id && "style" in item ) { 
            let stl = item.style; 
            const { default: _omit, ...custom_style } = item.style 
            console.log(custom_style)
            custom_style_arr.push(custom_style)
            }
        })
        custom_style = custom_style_arr.pop()
        if ( custom_style !== undefined && Object.keys(custom_style).length === 0 ){ msg = '{"font-size": "16px"}' } else { msg = JSON.stringify(custom_style)}
        showpop({type: "bubble", id: target_id, action: text, obj: bubble_obj, pop_text: msg })
    }
    if (text=="toggleView"){
        toggleBubbleText(bubble_obj, target_id)
    }
}

function getMaxID(){
        let max_id = -1
        data.forEach( d=> {
            max_id = d.id > max_id ? d.id : max_id
        })
        return max_id + 1
}
function handleHandleContext(text, obj, target_id){
    if (text == "delete"){
        console.log(obj, target_id)
        let idToRemove = obj.getAttribute("parent_id")
        const exists = data.some(item => item.id == idToRemove);
        console.log(exists)
        if (exists){
        const index = data.findIndex(item => item.id == idToRemove);
        console.log(index)
        console.log(data)
        if (index !== -1) {data.splice(index, 1)}
        console.log(data)
        e = document.getElementById(idToRemove)
        e.remove()
        }
    }
    if (text == "addTag"){
        let msg = ''
        data.forEach(item=>{if(item.id == target_id){ if("tag" in item){ msg = item.tag.join() } }})
        showpop({type: "handle", id: target_id, action: text, obj: obj, pop_text: msg })
    }
    if (text == "editTitle"){
        let msg = ''
        data.forEach(item=>{if(item.id == target_id){ if("title" in item){ msg = item.title } }})
        showpop({type: "handle", id: target_id, action: text, obj: obj, pop_text: msg })
    }
}
function handleDrawAreaContext(text, obj, target_id){
    if (text == "addBubble"){ 
        let max_id = getMaxID()
        let x = -global_x_moves
        let y = -global_y_moves
        console.log(global_x_moves)
        console.log(global_y_moves)
        new_bubble = {id: max_id, type: "bubble", style: {"default": "bubble"}, x: x, y: y, title: ".\n\n", text: "i am new bubble"}
        data.push(new_bubble)
        createNodes(getNodeParent(),[new_bubble])
    }
    if (text == "addLink"){
        let max_id = getMaxID()
        let x = -global_x_moves
        let y = -global_y_moves
        console.log(global_x_moves)
        console.log(global_y_moves)
        let link  = prompt("Enter Link");
        let link_text = prompt("Enter text");
        new_link = {id: max_id, type: "link", style: {"default": "link"}, x: x, y: y, title: ".", href: link,  text: link_text}
        data.push(new_link)
        createNodes(getNodeParent(),[new_link])
    }
    if (text == "addImage"){
        let max_id = getMaxID()
        let x = -global_x_moves
        let y = -global_y_moves
        let link  = prompt("Enter image name", g_clicked_key);
        let img = link
        new_img = {id: max_id, type: "img", style: {"default": "img"}, x: x, y: y, title: ".", name: img}
        data.push(new_img)
        createNodes(getNodeParent(),[new_img])
    }
    if (text == "addGoto"){
        let max_id = getMaxID()
        let x = -global_x_moves
        let y = -global_y_moves
        let name  = prompt("Enter name");
        let id = prompt("Enter Id")
        if (parseInt(id) === null || Number.isNaN(parseInt(id))) {alert("Value is null or NaN");return}
        new_goto = {id: max_id, type: "goto", style: {"default": "goto"}, x: x, y: y, title: ".", text: name, gotoid: id}
        data.push(new_goto)
        createNodes(getNodeParent(),[new_goto])
    }
}

function setNodeWidth(e, id, w = ''){
    parent = getNodeParent()
        data.forEach(item => {
            if (item.id == id){
                if (w==''){
                    if ( "width" in item ){ delete item.width}
                    //e.style.width = ''
                } else {
                    item.width = w
                    //e.style.width = item.width + "px"
                }
            }
        });
}

function setNodeHeight(e, id, h = ''){
    parent = getNodeParent()
        data.forEach(item => {
            if (item.id == id){
                if ( h == ''){
                    if ( "height" in item ){ delete item.height}
                    //e.style.height = ''
                }
                else {
                item.height = h
                //e.style.height = item.height + "px"
                }
            }
        });
}

function searchTag(tag){
    let res = []
    data.forEach(item=>{
        if ("tag" in item && tag.split(',').every(e=>item.tag.includes(e))){
            res.push(item.id)
        }
    })
    if (res.length>0){alert(res.join('\n'))}
}

g_make_context_flag=false
function makeContext(element){    
    
    let list_items = null
    // Show context menu on right-click
    element.addEventListener("contextmenu", (event) => {
        event.preventDefault(); // Prevent default right-click menu
        event.stopPropagation(); // Prevent default right-click menu
        console.log("event listener")
        type = element.getAttribute("item_sub_type")
        console.log(type)
        if (g_make_context_flag) return
        g_make_context_flag = true
        console.log(event.target)
        if (type == "bubble"){ list_items = createBubbleContext(event.target) }
        if (type == "quiz"){ list_items = createQuizContext(event.target) }
        if (type == "draw_area"){ list_items = createDrawAreaContext(event.target) }
        if (type == "handle"){ list_items = createHandleContext(event.target) }
        list_items.id = "context_menu_list"
        document.getElementById("contextMenu").appendChild(list_items)
        
        const parentRect = getNodeParent().getBoundingClientRect()
        startX = event.pageX - parentRect.left
        startY = event.pageY - parentRect.top
        contextMenu.style.left = `${startX}px`;
        contextMenu.style.top = `${startY}px`;
        contextMenu.style.display = "block";
        console.log(g_make_context_flag)
    });
    // Hide context menu when clicking elsewhere
    document.addEventListener("click", () => {
       if (g_make_context_flag) {
        let list_items = document.getElementById("context_menu_list")
        console.log(document.getElementById("contextMenu"), list_items)
        document.getElementById("contextMenu").removeChild(list_items)
        list_items.remove()
    }
       g_make_context_flag = false
       contextMenu.style.display = "none";
    });
}

g_last_top_e = { e: null, zIndex: null}
//applies only to bubble
function node_on_top(element, element_zindex_capture){
    if ( g_last_top_e.e == null || ( g_last_top_e.e != element )) {
        if (g_last_top_e.e){
            g_last_top_e.e.style.zIndex = g_last_top_e.zIndex
        }
        g_last_top_e.e = element;
        g_last_top_e.zIndex = element_zindex_capture;
    }
    element.style.zIndex = zIndices.topSpot;
}
function overrideDraggableIpad(element){
    // maximize section
    const typeHandlers = {max : { bubble: maximizeBubble, quiz: maximizequiz }, min: { bubble: minimizeBubble, quiz: minimizequiz }};
    if (element.getAttribute("item_type") === 'node' && ( element.querySelector('[item_sub_type="bubble"]') ||  element.querySelector('[item_sub_type="quiz"]') ) ){
        const resizerElement = element.querySelector('[item_sub_type="resizer"]');
        const bubbleElement = element.querySelector('[item_sub_type="bubble"]');
        const quizElement = element.querySelector('[item_sub_type="quiz"]');
        const e = bubbleElement || quizElement
        const e_type = e.getAttribute("item_sub_type")
        const parentId = resizerElement.getAttribute("parent_id");
        const element_zindex_capture = element.style.zIndex
        let width = null;
        let height = null;
        let current_item = null;
        data.forEach(item=>{ if(item.id == parentId ) { current_item = item; width = item.width; height = item.height } })
        console.log(current_item,width,height,resizerElement,bubbleElement,parentId)
        if ( "_max" in current_item && current_item._max){ 
            typeHandlers['min'][e_type](resizerElement, width, height)
            //bubbleElement.style.backgroundColor = ""
            current_item._max=false
        } else {
            typeHandlers['max'][e_type](resizerElement)
            //bubbleElement.style.backgroundColor = "#1f1f1f"
            current_item._max=true
        }
        node_on_top(element, element_zindex_capture)
    }
}

function makeDraggable(element, parent, handle = null) {
    const dragTarget = handle || element;
    element.style.position = 'absolute';
    dragTarget.style.cursor = 'move';
    let offsetX, offsetY, isDragging = false;
    let startX = 0, startY = 0;
    let zIndexValue = null
    let element_zindex_capture = null
    function startDrag(x, y) {
        console.log(element)
        if(( ( isIPad() || isPhone() ) && element.getAttribute("item_type") === 'node')){
        //if((true && element.getAttribute("item_type") === 'node')){
            overrideDraggableIpad(element)
            return
        }
        const parentRect = parent.getBoundingClientRect();
        const elemRect = element.getBoundingClientRect();
        offsetX = x - elemRect.left;
        offsetY = y - elemRect.top;
        startX = elemRect.left - parentRect.left;
        startY = elemRect.top - parentRect.top;
        isDragging = true;
        element_zindex_capture = element.style.zIndex
        element.style.zIndex = 1000;
    }

    function dragMove(x, y) {
        if (!isDragging) return;
        const parentRect = parent.getBoundingClientRect();
        const newX = x - parentRect.left - offsetX;
        const newY = y - parentRect.top - offsetY;
        element.style.left = newX + 'px';
        element.style.top = newY + 'px';
    }

    function endDrag() {
        if (!isDragging) return;
        isDragging = false;
        if (element.getAttribute("item_type") == 'node') {
            node_on_top(element, element_zindex_capture)
        } else {
            element.style.zIndex = element_zindex_capture;
        }
        
        const parentRect = parent.getBoundingClientRect();
        const elemRect = element.getBoundingClientRect();
        const endX = elemRect.left - parentRect.left;
        const endY = elemRect.top - parentRect.top;
        const deltaX = Math.round(endX - startX);
        const deltaY = Math.round(endY - startY);
        if (element.id === "anchor") {
            resetAnchorAndMoveNodes(element, parent, deltaX, deltaY);
        } else if (element.id && element.getAttribute("item_type") === 'node') {
            updateNodePosition(element.id, deltaX, deltaY);
        }
    }

    // --- MOUSE EVENTS ---
    dragTarget.addEventListener('mousedown', function (e) {
        if (e.button === 2) return; // Right-click
        startDrag(e.clientX, e.clientY);
        e.preventDefault();
        e.stopPropagation();
    });

    document.addEventListener('mousemove', function (e) {
        dragMove(e.clientX, e.clientY);
    });

    document.addEventListener('mouseup', function () {
        endDrag();
    });

    // --- TOUCH EVENTS ---
    dragTarget.addEventListener('touchstart', function (e) {
        const touch = e.touches[0];
        startDrag(touch.clientX, touch.clientY);
        e.preventDefault();
        e.stopPropagation();
    }, { passive: false });

    document.addEventListener('touchmove', function (e) {
        if (!isDragging) return;
        const touch = e.touches[0];
        dragMove(touch.clientX, touch.clientY);
        e.preventDefault();
    }, { passive: false });

    document.addEventListener('touchend', function () {
        endDrag();
    });
}


    global_x_moves = 0 
    global_y_moves = 0

    g_global_moves = []
    function goToNode(id){
        id = parseInt(id)
        if ( id == -1){
            goBack()
            return
        }
        if ( ! ( data.map(d=>d.id).includes(id) ) ){

            alert("id not found:"+id)
            return
        }
        move_to_x = null
        move_to_y = null
        g_global_moves.push([global_x_moves, global_y_moves])
        data.forEach(item=>{
            if ( item.id == id ){
                move_to_x = item.x
                move_to_y = item.y
            }
        })
        if ( move_to_x == null ){return}
        global_x_moves = - move_to_x
        global_y_moves = -  move_to_y 
        data.forEach(item=>{
            item._calculatedX = item.x + global_x_moves
            item._calculatedY = item.y + global_y_moves
            setNodePosition(item.id)
        })
    }

    function callGoToNode(id=null){
        if (id==null){ goToNode(document.getElementById("input_goto").value) }
        else if ( id == -2 ){ goToNode(helper.get_random().id) }
        else { goToNode(id) }
    }

    function goBack(){
        if (g_global_moves.length>0){
            let xy = g_global_moves.pop()
            let move_to_x = xy[0]
            let move_to_y = xy [1]
            global_x_moves = move_to_x
            global_y_moves = move_to_y
            data.forEach(item=>{
                item._calculatedX = item.x + global_x_moves
                item._calculatedY = item.y + global_y_moves
                setNodePosition(item.id)
            })
        }
        else {
            // do nothing
        }
    }

    function resetAnchorAndMoveNodes(anchor, parent, x, y){
        global_x_moves += x 
        global_y_moves += y
        shiftNodePosition(x, y)
        setPositionByPercentage(anchor, 50, 50, parent)
    }

    function getNodeParent(){
        return document.querySelector('#draw_area')
    }

    function setNodePosition(id){
        parent = getNodeParent()
        data.forEach(item => {
            if (item.id == id){
                div = document.getElementById(id)
                if (item._calculatedX + div.clientWidth < 0 || item._calculatedX > parent.clientWidth || item._calculatedY + div.clientHeight < 0 || item._calculatedY > parent.clientHeight)
                    {div.style.visibility = "hidden"}
                else
                    {div.style.visibility = "visible"}
                setPositionByCoords(document.getElementById(id), item._calculatedX, item._calculatedY, parent)
            }
        });
    }

    function updateNodePosition(id, x, y){
        data.forEach(item =>{
            if (item.id == id){
                item.x += x
                item.y += y
                item._calculatedX += x
                item._calculatedY += y
                
                setNodePosition(id)
            }
        })
    }

    function shiftNodePosition(shift_x = 0, shift_y = 0){
        parent = getNodeParent()
        data.forEach(item => {
            const id = item.id
            const div = document.getElementById(id)
            if (div) {
                const pos = getPosition(div, parent)
                item._calculatedX = pos.x + shift_x
                item._calculatedY = pos.y + shift_y
                setNodePosition(id)
            }
        })
    }

    function setPositionByCoords(element, x, y, parent){
        if (parent){
            element.style.position = 'absolute'
            element.style.left = x + 'px'
            element.style.top = y + 'px'
        } else {
            element.style.left = x + 'px'
            element.style.top = y + 'px'
        }
    }

    function setPositionByPercentage(element, x , y, parent){
        if (parent){
            element.style.position = 'absolute'
            element.style.left = x + '%'
            element.style.top = y + '%'
        } else {
            element.style.left = x + '%'
            element.style.top = y + '%'
        }
    }

    function getPosition(element, parent){
        const elemRect = element.getBoundingClientRect()
        const parentRect = parent.getBoundingClientRect()
        const pos = {
            x: Math.round(elemRect.left - parentRect.left),
            y: Math.round(elemRect.top - parentRect.top),
        }
        return pos
    }

    function createQuizApp(app, questions) {
    let currentIndex = 0;

    function createCardAnswer(question) {
    const wrapper = document.createElement('div');

    const revealBtn = document.createElement('div');
    revealBtn.textContent = question.q;
    revealBtn.style.whiteSpace = 'pre-wrap';

    const answer = document.createElement('div');
    answer.style.whiteSpace = 'pre-wrap';
    answer.className = 'quiz-answer';
    answer.style.display = 'none';
    answer.textContent = question.a;

    revealBtn.onclick = () => {
        answer.style.display = 'block';
        revealBtn.style.display = 'none';
        showNextButton(); // Move to next after reveal
        showHint(wrapper,question)
    };

    wrapper.appendChild(revealBtn);
    wrapper.appendChild(answer);
    
    return wrapper;
    }


    function createFillInTheBlanksQuestion(question) {
    let attemptCount=0
    const wrapper = document.createElement('div');
    const parts = question.q.split("____");
    const answerArray = Array.isArray(question.a) ? question.a : [question.a];

    const form = document.createElement('div');
    const inputs = [];

    parts.forEach((part, i) => {
        form.appendChild(document.createTextNode(part));
        if (i < answerArray.length) {
        const input = document.createElement('input');
        input.type = 'text';
        input.size = Math.max(answerArray[i].length, 5);
        input.className = 'quiz-input';
        inputs.push(input);
        form.appendChild(input);
        }
    });

    const submitBtn = document.createElement('button');
    submitBtn.textContent = "Submit";
    submitBtn.className = 'quiz-button';

    submitBtn.onclick = () => {
        let allCorrect = true;
        attemptCount++;
        inputs.forEach((input, idx) => {
        const val = input.value.trim()//.toLowerCase();
        const correct = answerArray[idx]//.toLowerCase();

        if (val === correct) {
            input.classList.remove('quiz-incorrect');
            input.classList.add('quiz-correct');
        } else {
            input.classList.add('quiz-incorrect');
            submitBtn.classList.add('quiz-incorrect')
            allCorrect = false;
        }
        });

        if (allCorrect || attemptCount >= 3 ) {
        disableInputs(inputs, submitBtn);
        showNextButton();
        showHint(wrapper,question)
        } 
        if (attemptCount >= 3) {
            inputs.forEach((input, idx) => {
            input.value = answerArray[idx];
            input.classList.remove('quiz-incorrect');
            input.classList.add('quiz-correct');
            });
        }
    };

    wrapper.appendChild(form);
    wrapper.appendChild(submitBtn);
    return wrapper;
    }



function createOptionsQuestion(question) {
    const wrapper = document.createElement('div');
    wrapper.style.whiteSpace = 'pre-wrap';

    // Add question text
    const questionText = document.createElement('div');
    questionText.innerHTML = question.q;
    wrapper.appendChild(questionText);

    const selected = new Set();
    let attemptCount = 0;
    const correctAnswer = new Set(question.a);
    const optionButtons = [];

    const areSetsEqual = (a, b) => a.size === b.size && [...a].every(x => b.has(x));

    // Submit button (initially hidden)
    const submitBtn = document.createElement('button');
    submitBtn.textContent = "Submit";
    submitBtn.className = 'quiz-button';
    submitBtn.style.display = 'none';

    // Container for the options
    const optionsContainer = document.createElement('div');
    showOptionsContainer = null;
    // "Show Options" button inside its own div
    if ( g_think ){
    showOptionsContainer = document.createElement('div');
    const showOptionsBtn = document.createElement('button');
    showOptionsBtn.textContent = "Show Options";
    showOptionsBtn.className = 'quiz-button';
    showOptionsBtn.onclick = show_options;
    showOptionsContainer.appendChild(showOptionsBtn);
    wrapper.appendChild(showOptionsContainer); // below question
    }
    else {
        show_options()
    }
    function show_options() {
        // Hide "Show Options" button
        if(showOptionsContainer) { showOptionsContainer.style.display = 'none'; }

        // Create and show option buttons
        question.options.forEach((opt, index) => {
            const btn = document.createElement('div');
            btn.style.whiteSpace = 'pre-wrap';
            btn.className = 'quiz-option';
            btn.innerHTML = opt;
            // Make div focusable via tab
            btn.setAttribute('tabindex', '0');
            btn.setAttribute('role', 'button'); // Optional: For screen readers
            // ✅ Shared handler for mouse & keyboard
            const toggleSelection = () => {
                submitBtn.classList.remove('quiz-incorrect');
                if (btn.classList.contains('quiz-selected')) {
                    btn.classList.remove('quiz-selected');
                    selected.delete(index);
                } else {
                    btn.classList.add('quiz-selected');
                    selected.add(index);
                }
            };
        // ✅ Mouse click
        btn.onclick = toggleSelection;

        // ✅ Keyboard: Enter or Space
        btn.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault(); // Prevent scrolling on space
                toggleSelection();
            }
        });
            optionButtons.push(btn);
            optionsContainer.appendChild(btn);
        });

        submitBtn.style.display = 'inline-block'; // Show the submit button
    };

    // Submit button behavior
    submitBtn.onclick = () => {
        attemptCount++;
        if (areSetsEqual(correctAnswer, selected) || attemptCount >= 3) {
            disableInputs(optionButtons, submitBtn);
            showNextButton();
            optionButtons.forEach((btn, i) => {
                if (correctAnswer.has(i)) {
                    btn.classList.add('quiz-correct');
                }
            });
            showHint(wrapper, question);
        } else {
            submitBtn.classList.add('quiz-incorrect');
        }

        optionButtons.forEach(btn => btn.classList.remove('quiz-selected'));
        selected.clear();
    };

    // Assemble everything
    wrapper.appendChild(optionsContainer);
    wrapper.appendChild(submitBtn);

    return wrapper;
}






    function renderQuestion() {
    app.innerHTML = '';

    const question = questions[currentIndex];
    const container = document.createElement('div');
    container.innerHTML = `<h3 style="border: none; margin: 0;">Q${currentIndex + 1}:</h3>`;

    if (question.options) {
        container.appendChild(createOptionsQuestion(question));
    } else if (typeof question.q === 'string' && question.q.includes('____')) {
        container.appendChild(createFillInTheBlanksQuestion(question));
    }
    else {
        container.appendChild(createCardAnswer(question));
    }
    app.appendChild(container);
    }


    function disableInputs(inputs, submitBtn) {
        inputs.forEach(input => input.disabled = true);
        submitBtn.style.display = 'none';
    }

    function disableOptions(container) {
        const options = container.querySelectorAll('.quiz-option');
        options.forEach(opt => opt.classList.add('quiz-disabled'));
    }
    function showHint(wrapper, question){
        if (!("h" in question)){return}
        const hint = document.createElement('div');
        hint.classList.add('quiz-hint');
        hint.style.whiteSpace = 'pre-wrap';
        featchCustomParsedData(hint, question.h)
        //hint.innerText = "Hint:" + question.h
        wrapper.appendChild(hint)
    }
    function showNextButton() {
        const controls = document.createElement('div');
        controls.className = 'quiz-controls';

        const nextBtn = document.createElement('button');
        nextBtn.textContent = currentIndex < questions.length - 1 ? 'Next' : 'Start Over';
        nextBtn.className = 'quiz-button';
        nextBtn.onclick = () => {
        currentIndex = (currentIndex + 1) % questions.length;
        renderQuestion();
        };

        controls.appendChild(nextBtn);
        app.appendChild(controls);
    }

    // Public API
    return {
        start: () => renderQuestion()
    };
    }
    function createQuizContext(t){
        options = ["editText"]
        parent = t.closest('[item_sub_type="quiz"]');
        return fillContextOptions(options, parent)
    }
    function createBubbleContext(t){
        options = ["editText", "toggleView", "editStyle", "maximize", "minimize"]
        return fillContextOptions(options, t)
    }
    function createDrawAreaContext(t){
        options = ["addBubble", "addLink", "addImage", "addGoto"]
        return fillContextOptions(options, t)
    }
    function createHandleContext(t){
        options = ["delete", "addTag", "editTitle"]
        return fillContextOptions(options, t)
    }
    function fillContextOptions(options, t){
        u = document.createElement("div")
        options.forEach(item => {
            l = document.createElement("div")
            l.textContent = item
            l.addEventListener('click', function() {
                console.log(this,t)
                if (t.getAttribute("item_sub_type") == "quiz"){handleQuizContext(this.textContent,t, t.getAttribute("parent_id"))}
                if (t.getAttribute("item_sub_type") == "bubble"){handleBubbleContext(this.textContent,t, t.getAttribute("parent_id"))}
                if (t.getAttribute("item_sub_type") == "draw_area"){handleDrawAreaContext(this.textContent,t, t.getAttribute("parent_id"))}
                if (t.getAttribute("item_sub_type") == "handle"){handleHandleContext(this.textContent,t, t.getAttribute("parent_id"))}
            });
            u.appendChild(l)
        })
        return u
    }
    function setHandleText(e, data){
        console.log(data)
        title = null
        if ("last_visited" in data){
            // Get today's date
            const today = new Date();
            // Parse last_visited date
            const lastVisited = new Date(data.last_visited);
            // Calculate difference in milliseconds
            const diffInMs = today - lastVisited;
            // Convert milliseconds to days
            const diffInDays = Math.floor(diffInMs / (1000 * 60 * 60 * 24));
            title = `${diffInDays}day${diffInDays > 0 ? 's' : ''}:` + data.title;
        } else {
            title = data.title
        }
        e.textContent = title ? title : '.'
    }
    function createHandle(data, parent_id){
        handle = document.createElement("div")
        setHandleText(handle, data)
        handle.setAttribute("item_sub_type", "handle");
        handle.setAttribute("parent_id", parent_id);
        handle.classList.add("handle");
        makeContext(handle)
        return handle
    }
    function applyStyle(data, e){
        if ("style" in data){
            Object.entries(data.style).forEach(([key,value])=>{
                if (key != "default"){
                    e.style[key] = value
                }
            })
        }
    }
    function isPhone() {
    const ua = navigator.userAgent || navigator.vendor || window.opera;

    // Detect iPhone or iPod explicitly
    const isIPhoneOrIPod = /iPhone|iPod/.test(ua);

    // Detect Android phones (but not tablets, which usually don't include "Mobile")
    const isAndroidPhone = /Android/.test(ua) && /Mobile/.test(ua);

    return isIPhoneOrIPod || isAndroidPhone;
    }
    function isIPad() {
    // For newer iPads running iPadOS (which report as Mac)
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
    const isMac = navigator.platform === 'MacIntel';
    const hasTouch = navigator.maxTouchPoints > 1;
    return isIOS || (isMac && hasTouch);
    }
    function decodeHtmlEntity(entity) {
    const txt = document.createElement("textarea");
    txt.innerHTML = entity;
    return txt.value;
    }
    function setQuizData(e,json){
        e.innerHTML = ''; // Clear start button
        const quizApp = createQuizApp(e, json);
        quizApp.start();
    }
    function createQuiz(data, parent_id){
        handle = createHandle(data, parent_id)
        quizData = data.text
        const new_element = document.createElement('div')
        const quizButton = document.createElement('button');
        quizButton.className = 'quiz-button';
        quizButton.id = 'quiz-start-button';
        quizButton.textContent = 'Start Quiz';
        new_element.appendChild(quizButton);
        setQuizData(new_element, quizData)
        new_element.style.position = 'relative'
        new_element.setAttribute("item_sub_type", "quiz");
        new_element.setAttribute("parent_id", parent_id);
        new_element.classList.add(data.style.default);
        applyStyle(data, new_element)
        new_element.onclick=makeContext(new_element)
        return {handle: handle, element: new_element}
    }
    function createGoto(data, parent_id){
        handle = createHandle(data, parent_id)
        const new_element = document.createElement('div')
        new_element.innerHTML = data.text
        new_element.style.position = 'relative'
        new_element.setAttribute("item_sub_type", "goto");
        new_element.setAttribute("parent_id", parent_id);
        new_element.classList.add(data.style.default);
        applyStyle(data, new_element)
        new_element.onclick=() => callGoToNode(data.gotoid);
        return {handle: handle, element: new_element}
    }
    function createImg(data, parent_id){
        handle = createHandle(data, parent_id)
        const new_element = document.createElement('img')
        new_element.src = images[data.name]
        new_element.style.position = 'relative'
        new_element.setAttribute("item_sub_type", "img");
        new_element.setAttribute("parent_id", parent_id);
        new_element.setAttribute("alt", data.name)
        new_element.classList.add(data.style.default);
        applyStyle(data, new_element)
        return {handle: handle, element: new_element}
    }
    function createLink(data, parent_id){
        handle = createHandle(data, parent_id)
        const new_element = document.createElement('a')
        new_element.href = data.href
        new_element.textContent = data.text
        new_element.target = '_blank'; // Open in new tab
        new_element.style.position = 'relative'
        new_element.setAttribute("item_sub_type", "link");
        new_element.setAttribute("parent_id", parent_id);
        new_element.classList.add(data.style.default);
        applyStyle(data, new_element)
        return {handle: handle, element: new_element}
    }

   /*function setBubbleData(outputDiv, encodedText){
        encodedText = decodeHtmlEntity(encodedText)
        outputDiv.innerHTML = ''
        //const regex = /\[size=(\d+)\]([\s\S]*?)\[\/size\]/g;
        //this helps to escape raw data like \[size=24]abc\[/size\  ]
         const regex = /(?<!\\)\[(size|color)=([^\]]+)\]([\s\S]*?)\[\/\1\]/g;
        let lastIndex = 0
        let match
        console.log(outputDiv, encodedText)
        while( ( match = regex.exec(encodedText)) ){
            if (match.index > lastIndex ){
                const before = encodedText.slice(lastIndex, match.index)
                console.log(before)
                outputDiv.appendChild(document.createTextNode(before))
            }

        // Create a span for the matched tag content
        const span = document.createElement('span');

        if (match[1] === 'size') {
          // match[2] is font size (number)
          span.style.fontSize = match[2] + 'px';
        } else if (match[1] === 'color') {
          // match[2] is color value (e.g. 'red', '#ff0000')
          span.style.color = match[2];
        }

        span.textContent = match[3];

            //span does nothing on right click but pops up bubble edit menu then on rightclick doess nothing causing confusion
            span.addEventListener("contextmenu", function(e){
                e.preventDefault()
                e.stopPropagation()
            })
            console.log(span)
            outputDiv.appendChild(span)


            lastIndex = regex.lastIndex
        }

        if (lastIndex < encodedText.length){
            outputDiv.appendChild(document.createTextNode(encodedText.slice(lastIndex)))
            console.log(encodedText.slice(lastIndex))
        }
        console.log(outputDiv)
        return 
    }*/

    
    function featchCustomParsedData(outputDiv, encodedText) {
    encodedText = decodeHtmlEntity(encodedText);
    outputDiv.innerHTML = '';

    // Local helper function to parse [s], [c], [g] tags
    function parseSegment(text) {
        // Font size: [s=20]Text[/s]
        text = text.replace(/\[s=([^\]]+)\]([\s\S]*?)\[\/s\]/g, (_, size, content) => {
        return `<span style="font-size: ${size}px;">${content}</span>`;
        });

        // Color: [c=red]Text[/c]
        text = text.replace(/\[c=([^\]]+)\]([\s\S]*?)\[\/c\]/g, (_, color, content) => {
        return `<span style="color: ${color};">${content}</span>`;
        });

        // Goto button: [g=123]Click me[/g]
        text = text.replace(/\[g=(\d+)\]([\s\S]*?)\[\/g\]/g, (_, nodeId, content) => {
        return `<span class="goto-button" onclick="callGoToNode(${nodeId})">${content}</span>`;
        });

        // External links: [a=https://example.com]Text[/a]
        text = text.replace(/\[a=([^\]]+)\]([\s\S]*?)\[\/a\]/g, (match, linkTarget, content) => {
        return `<a class="inline-link" href="${linkTarget}" target="_blank" rel="noopener noreferrer">${content}</a>`;
        });

        return text;
    }

    // Split around [htmlcodearea] and [/htmlcodearea]
    const parts = encodedText.split(/\[\/?htmlcodearea\]/);
    let isHtmlBlock = false;

    for (let part of parts) {
        if (isHtmlBlock) {
        // Insert raw HTML directly
        outputDiv.innerHTML += part;
        } else {
        // Escape for plain text, then apply formatting
        const tempDiv = document.createElement("div");
        tempDiv.textContent = part;
        const formatted = parseSegment(tempDiv.innerHTML);
        outputDiv.innerHTML += formatted;
        }
        isHtmlBlock = !isHtmlBlock;
    }
    }

    function setBubbleData_v1(outputDiv, encodedText) {
    encodedText = decodeHtmlEntity(encodedText);
    outputDiv.innerHTML = '';

    function parseSegment(text) {
    // Replace [s=...] tags with font-size spans
    text = text.replace(/\[s=([^\]]+)\]([\s\S]*?)\[\/s\]/g, (_, size, content) => {
        return `<span style="font-size: ${size}px;">${content}</span>`;
    });

    // Replace [c=...] tags with color spans
    text = text.replace(/\[c=([^\]]+)\]([\s\S]*?)\[\/c\]/g, (_, color, content) => {
        return `<span style="color: ${color};">${content}</span>`;
    });

    // Replace [g=...] tags with clickable span styled as button
    text = text.replace(/\[g=(\d+)\]([\s\S]*?)\[\/g\]/g, (_, nodeId, content) => {
        return `<span class="goto-button" onclick="callGoToNode(${nodeId})">${content}</span>`;
    });

    return text;
    }


    // Add context menu listener on the entire output div
    outputDiv.addEventListener('contextmenu', e => {
        e.preventDefault();
        e.stopPropagation();
        // You can customize what happens on right-click here
        // For example: show a custom menu
    });

    outputDiv.innerHTML=parseSegment(encodedText);
    }

    function setBubbleData_v0(outputDiv, encodedText) {
      encodedText = decodeHtmlEntity(encodedText);
      outputDiv.innerHTML = '';

      function parseSegment(text) {
        const container = document.createDocumentFragment();

        const regex = /(?<!\\)\[(size|color)=([^\]]+)\]([\s\S]*?)\[\/\1\]/g;
        let lastIndex = 0;
        let match;

        while ((match = regex.exec(text))) {
          // Text before the tag
          if (match.index > lastIndex) {
            container.appendChild(document.createTextNode(text.slice(lastIndex, match.index)));
          }

          // Create a span with style according to tag
          const span = document.createElement('span');
          if (match[1] === 'size') {
            span.style.fontSize = match[2] + 'px';
          } else if (match[1] === 'color') {
            span.style.color = match[2];
          }

          // Recursively parse inner content to support nested tags
          span.appendChild(parseSegment(match[3]));

          // Prevent context menu confusion
          span.addEventListener('contextmenu', e => {
            e.preventDefault();
            e.stopPropagation();
          });

          container.appendChild(span);
          lastIndex = regex.lastIndex;
        }

        // Remaining text after last tag
        if (lastIndex < text.length) {
          container.appendChild(document.createTextNode(text.slice(lastIndex)));
        }

        return container;
      }

      outputDiv.appendChild(parseSegment(encodedText));
    }


    function createBubble(data, parent_id){
        handle = createHandle(data, parent_id)
        const new_element = document.createElement('div')
        //new_element.textContent = decodeHtmlEntity(data.text)
        //setBubbleData( new_element, 'Hello [size=24] abc [/size] def ghi [size=24] def [/size]' )
        //setBubbleData( new_element, data.text )
        if ("show" in data){ showBubbleText(data.show, data.text, new_element) }
        else { showBubbleText(true, data.text, new_element) }
        new_element.style.position = 'relative'
        new_element.setAttribute("item_sub_type", "bubble");
        new_element.setAttribute("parent_id", parent_id);
        new_element.classList.add(data.style.default);
        applyStyle(data, new_element)
        // this is only for testing
        //applyRandomTextColor(new_element)
        new_element.onclick=makeContext(new_element)
        return {handle: handle, element: new_element}
    }

    function createNodes(parent, nodes){
        console.log(nodes)
        nodes.forEach(item=>{
            console.log(item)
            if (document.getElementById(item.id)){ alert(item.id.toString()+':id already taken'); return }
            new_element = null
            container = null
            resize_node = null
            item._calculatedX = item.x + global_x_moves
            item._calculatedY = item.y + global_y_moves
            const node = document.createElement("div")
            node.id = item.id
            node.style.zIndex=zIndices[item.type]
            if (item.type == "bubble" || item.type == "quiz"){
            resize_node  = document.createElement("div")
            resize_node.setAttribute("item_sub_type", "resizer");
            resize_node.setAttribute("parent_id", node.id);
            resize_node.classList.add("resize_node")
            //makeResizable(resize_node)
            if (["height"] in item) { resize_node.style.height = item.height + "px" } else { resize_node.style.height = "auto" }
            if (["width"] in item) { resize_node.style.width = item.width + "px" } else { resize_node.style.width = "auto" }
            observer.observe(resize_node)
            container =  resize_node
            node.appendChild(resize_node)
            }
            else {
                container = node
            }
            

            node.classList.add('node');
            if (item.type == "bubble") { new_element = createBubble(item, item.id)}
            if (item.type == "link") { new_element = createLink(item, item.id)}
            if (item.type == "img") { new_element = createImg(item, item.id)}
            if (item.type == "goto") { new_element = createGoto(item, item.id)}
            if (item.type == "quiz") { new_element = createQuiz(item, item.id)}
            handle = new_element['handle']
            new_element = new_element['element']
            node.setAttribute("item_type", "node");
            console.log(handle,new_element)
            if(handle){container.appendChild(handle)}
            container.appendChild(new_element)
            if (node && (item.type == "bubble" || item.type == "quiz") ) {
                node.style.border = '1px solid #3C3C3B';
                node.style.padding = '9px';
                node.style.backgroundColor = '#1F1F1F';
            }
            parent.appendChild(node)
            setNodePosition(node.id)
            makeDraggable(node, parent, handle)
        })
    }

    pop_holder = null
    function showpop(initiator){
        console.log("at showpop", initiator)
        pop_holder = initiator
        pop = document.getElementById("draw_area_pop")
        pop_text = document.getElementById("pop_text")
        pop_text.value = initiator.pop_text 
        pop.style.visibility="visible"
        
    }
    
    function get_pop_input(){
        txt = document.getElementById('pop_text').value
        console.log(txt)
        document.getElementById("draw_area_pop").style.visibility = "hidden"
        call_pop_initiator(txt)
    }
    function call_pop_initiator(txt){
        console.log("call_pop_initiator")
        if (txt != null && pop_holder.type == "quiz" && pop_holder.action == "editText" )
        {
            try {
            const parsed = JSON.parse(txt); // try to parse it
            updateQuizText(pop_holder.id, txt)
            } catch (e) {
            // ❌ invalid, do nothing
            alert("Invalid Json")
            }
            
            
        }
        if (txt != null && pop_holder.type == "bubble" && pop_holder.action == "editText" )
        {
            updateBubbleText(pop_holder.id, txt)
            
        }
        if (txt != null && pop_holder.action == "editStyle" )
        {
            try{
            json=JSON.parse(txt)
            id = pop_holder.id
            data.forEach(item => {
                if (id == item.id) {
                    
                    Object.entries(json).forEach(([key, value]) => {
                        item['style'][key] = value
                    });
                applyStyle(item, pop_holder.obj)
                }
            });
            }
            catch(error)
            {
                console.log(txt)
                alert(error)
            }
        }
        if (pop_holder.type == "handle" && pop_holder.action == "addTag" ){
            if (txt != null && txt.trim() != ''){
                id = pop_holder.id
                console.log(txt, id)
                data.forEach(item => {
                    if (id == item.id) {
                        item['tag'] = txt.split(",")
                        }
                    });
            }
            else {
                user_confirm = confirm("delete tag ?")
                if (user_confirm) {
                    data.forEach(item => {
                        if (id == item.id && 'tag' in item) {
                            delete item.tag
                            }
                        });   
                }
            }
        }
        if (pop_holder.type == "handle" && pop_holder.action == "editTitle" ){
            id = pop_holder.id
            updateHandleText(id, txt)
        }
    pop_holder = null
    }
    function updateQuizText(id,txt){
        console.log("updateQuizText:"+id)
        jsonified_txt = JSON.parse(txt)
        data.forEach(item=>{
            if ( item.id == id ){ 
                item.text = jsonified_txt;
                e=document.getElementById(id)
                let quiz = e.querySelectorAll('[item_sub_type="quiz"]')[0]
                setQuizData(quiz, jsonified_txt)
            }
        })        
    }
    function updateBubbleText(id, txt){
        console.log('update bubble text', id, txt)
        data.forEach(item=>{
            if ( item.id == id ){ 
                item.text = txt; e=document.getElementById(id)
                //e.querySelectorAll('[item_sub_type="bubble"]')[0].textContent = decodeHtmlEntity(txt)
                let bubble = e.querySelectorAll('[item_sub_type="bubble"]')[0]
                featchCustomParsedData(bubble, txt)
            }
        })
    }
    function updateHandleText(id, txt){
        if (txt == null || txt.trim() == ''){ alert('invalid title')}
        console.log('update handle text', id, txt)
        data.forEach(item=>{
            if ( item.id == id ){ 
                item.title = txt; e=document.getElementById(id)
                let handle = e.querySelectorAll('[item_sub_type="handle"]')[0]
                setHandleText(handle, item)
            }
        })
    }
    const textColors = [
      'primary-text',
      'secondary-text',
      'tertiary-text',
      'accent-text',
      'error-text',
      'success-text',
      'warning-text', 'text-color-1',  'text-color-2',  'text-color-3',  'text-color-4',  'text-color-5',
  'text-color-6',  'text-color-7',  'text-color-8',  'text-color-9',  'text-color-10',
  'text-color-11', 'text-color-12', 'text-color-13', 'text-color-14', 'text-color-15',
  'text-color-16', 'text-color-17', 'text-color-18', 'text-color-19', 'text-color-20'
    ];

    function applyRandomTextColor(element) {
      const randomClass = textColors[Math.floor(Math.random() * textColors.length)];
      element.classList.add(randomClass);
    }
    helper = {
        'get_max_id': function get_max_id(){let maxid=-1;data.map(id=>{if(id.id>maxid){maxid=id.id}});console.log(maxid)},
        'get_node': function get_node(id){return data.filter(d=>d.id==id)},
        'get_random': function get_random() {return data[Math.floor(Math.random() * data.length)];}

    }
    g_think = false
    function setThink(){ g_think = !(g_think) }
</script>
<body>
    <div class="top"> Top Bar
        <button onclick="createNodes(getNodeParent(), data)">Add Element</button>
        <input type="file" id="image-input" accept="image/*" multiple style="display:none" onchange="loadImages()">
         <input type="file" id="FileInput" accept=".json" onchange="loadData()"/>
        <button onclick="document.getElementById('image-input').click()">Load images</button>
        <button onclick="downloadJSON()">download</button>
        <button onclick="callGoToNode(-1)">back</button>
        <button onclick="callGoToNode(-2)">random</button>
        <button onclick="setThink()">think</button>
        <input id="input_goto" placeholder="Enter Id(-1 back)"/>
    </div>
    <div class="container">
        <div class="sidebar" id = 'sidebar'>
        </div>
        <div class="main" id="draggable-main">
            <div id="draw_area" item_sub_type="draw_area">
                <div id = "draw_area_pop" style="z-index: 99;" item_sub_type="draw_area_pop">
                    <textarea id = "pop_text"></textarea>
                    <button onclick="get_pop_input()">submit</button>
                </div>
                <div id="contextMenu" style="z-index: 100;" class="context-menu">
                </div>
                <div id="anchor" style="z-index: 98;"></div>
                </div>
            </div>
        </div>
    </div>
    <script>
        window.onload = function(){
            const anchor = document.getElementById("anchor")
            const main = document.getElementById("draggable-main")
            const draw_area = document.getElementById("draw_area")
            makeDraggable(anchor, draw_area)
            makeContext(draw_area)
            document.getElementById("input_goto").addEventListener('keydown', function(event){
                event.stopPropagation()
                if (event.key == 'Enter'){
                    callGoToNode( document.getElementById("input_goto").value.trim() )
                }
            })
        }   
    </script>
</body>
</html>
