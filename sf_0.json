[
  {
    "id": 1,
    "type": "bubble",
    "style": {
      "default": "bubble",
      "font-size": "16px"
    },
    "x": 438,
    "y": 235,
    "title": ".",
    "text": "snowflake is saas\n\nsaas is a software hosted in cloud â˜ and delivered to user over internet such as browser",


    "height": 190,
    "width": 314
  },
  {
    "id": 2,
    "type": "bubble",
    "style": {
      "default": "bubble"
    },
    "x": 184,
    "y": 478,
    "title": ".",
    "text": "A virtual warehouse [s=24]ðŸ [/s], often referred to simply as a warehouse, is a cluster of compute [s=24]ðŸ’»ðŸ’»ðŸ’»ðŸ’» [/s] resources in Snowflake.",


    "height": 146,
    "width": 179
  },
  {
    "id": 4,
    "type": "bubble",
    "style": {
      "default": "bubble",
      "font-size": "12px",
      "color": "#ff9800"
    },
    "x": 405,
    "y": 474,
    "title": ".",
    "text": "Think like its a lot of computers\nproviding MEMORY and CPU power \n\\[s=24\\] &#x1f4aa \\[/size\\]\n[s=24] &#x1f4aa [/s]\nit may be in aws, azure or \neven in a basement somewhere \nwho cares ?",


    "height": 153,
    "width": 197
  },
  {
    "id": 6,
    "type": "bubble",
    "style": {
      "default": "bubble"
    },
    "x": 441,
    "y": 946,
    "title": ".",
    "text": "There are 2\ntypes of warehouse",


    "height": 100,
    "width": 100
  },
  {
    "id": 9,
    "type": "bubble",
    "style": {
      "default": "bubble"
    },
    "x": 685,
    "y": 1104,
    "title": ".",
    "text": "[s=24]standard[/s]\nsmallest size x small\nlargest size  [s=24]6x[/s]",


    "height": 109,
    "width": 192
  },
  {
    "id": 10,
    "type": "bubble",
    "style": {
      "default": "bubble",
      "font-size": "16px"
    },
    "x": 712,
    "y": 480,
    "title": ".",
    "text": "A warehouse can be resized up or down at any time, including while it is running and processing statements.",


    "height": 144,
    "width": 196
  },
  {
    "id": 11,
    "type": "bubble",
    "style": {
      "default": "bubble",
      "font-size": "44px"
    },
    "x": 736,
    "y": 615,
    "title": ".",
    "text": "&#x1f3c3",


    "height": 80,
    "width": 60
  },
  {
    "id": 12,
    "type": "bubble",
    "style": {
      "default": "bubble"
    },
    "x": 595,
    "y": 697,
    "title": ".",
    "text": "Increasing the size of a warehouse does not always improve data loading performance",


    "height": 61,
    "width": 171
  },
  {
    "id": 14,
    "type": "bubble",
    "style": {
      "default": "bubble",
      "font-size": "44px"
    },
    "x": 461,
    "y": 672,
    "title": ".",
    "text": "&#x1f69a",


    "height": 80,
    "width": 60
  },
  {
    "id": 15,
    "type": "bubble",
    "style": {
      "default": "bubble",
      "font-size": "12px",
      "color": "red"
    },
    "x": 586,
    "y": 771,
    "title": ".",
    "text": "Data loading performance is influenced more by the \n1 number of files being loaded\n2 the size of each file",


    "maximize": true,
    "height": 88,
    "width": 339
  },
  {
    "id": 16,
    "type": "bubble",
    "style": {
      "default": "bubble"
    },
    "x": 192,
    "y": 1056,
    "title": ".",
    "text": "[s=24] snowpark [/s]\nrecommended for running Snowpark workloads that has \nlarge memory [s=24]&#x1f9e0 [/s]\nrequirements or\ndependencies on a specific CPU  architecture\n\ni provide [s=24]16x[/s] memory by default\ncompared to standard",


    "height": 213,
    "width": 416
  },
  {
    "id": 17,
    "type": "goto",
    "style": {
      "default": "goto"
    },
    "x": 178,
    "y": -2,
    "title": ".",
    "text": "warehouse",
    "gotoid": "2"


  },
  {
    "id": 0,
    "type": "bubble",
    "style": {
      "default": "bubble"
    },
    "x": 0,
    "y": 0,
    "title": ".",
    "text": "root",


    "height": 44,
    "width": 38
  },
  {
    "id": 18,
    "type": "bubble",
    "style": {
      "default": "bubble"
    },
    "x": 2244,
    "y": 343,
    "title": ".",
    "text": "dynamic table\ntables that automatically refreshðŸ”„ based on a defined queryâ“ and target freshnessðŸŒ·",


    "height": 101,
    "width": 100
  },
  {
    "id": 19,
    "type": "link",
    "style": {
      "default": "link"
    },
    "x": 2353,
    "y": 343,
    "title": ".",
    "href": "https://docs.snowflake.com/en/user-guide/dynamic-tables-about#how-dynamic-tables-work",
    "text": "dynamic"
  },
  {
    "id": 20,
    "type": "bubble",
    "style": {
      "default": "bubble"
    },
    "x": 2222,
    "y": 449,
    "title": ".",
    "text": "When to use dynamic tables\n> avoid manually [c=#f1fa8c]data dependency[/c] tracking\n> materialize query results from ][c=#f1fa8c]multiple base tables[/c]\n> build multiple tables for data transformations in a pipeline\n>dont need [c=#f1fa8c]fine-grained control over refresh[/c] schedules",


    "height": 185,
    "width": 100
  },
  {
    "id": 21,
    "type": "bubble",
    "style": {
      "default": "bubble"
    },
    "x": 2390,
    "y": 448,
    "title": ".",
    "text": "[s=33]ðŸ”„[/s]\nDynamic tables are refreshed based on \n> [c=#50fa7b]target lag[/c] in mins\n> downstream target lag . dt1(every 1min) -> dt2 (every 30min). dt1 may refresh every 30 min.\n\nManual refresh\n> [c=#50fa7b]snowsight[/c] - monitoring - dynamic tables - select - refresh\n> [c=#50fa7b]ALTER[/c] DYNAMIC TABLE my_dynamic_table REFRESH\n",


    "height": 200,
    "width": 200
  },
  {
    "id": 22,
    "type": "goto",
    "style": {
      "default": "goto"
    },
    "x": 178,
    "y": 34,
    "title": ".",
    "text": "dynamicTable",
    "gotoid": "18"


  },{
    "id": 23,
  "type": "quiz",
  "style": {
   "default": "quiz",
   "fontFamily": "Comic Sans MS"
  },
    "x": 2752,
    "y": 367,
    "title": ".",
    "text": [
  {
    "q": "What is a key feature of Snowflake Dynamic Tables?",
    "options": [
      "automatically refresh based on a defined query and target freshness",
      "Manual refresh only",
      "Requires external orchestration",
      "Only supports batch data"
    ],
    "a": [0],
    "h": "Dynamic Tables are automatically updated as new data arrives, enabling near real-time data processing."
  },{
    "q": "The refresh frequency and freshness of the data are determined by the ____ (2) specified",
    "a": ["target lag"],
    "h": " a target lag of five minutes ensures that the data in the dynamic table is no more than five minutes behind updates to the base table."
  },
  {
    "q": "When are dynamic tables ideal to use?",
    "options": [
      "When you want to manually track data dependencies",
      "When you want to avoid managing refresh schedules",
      "When You need to materialize query results from multiple base tables without writing custom code",
      "When You need fine-grained control over refresh schedules",
      "You want to use a dynamic table as the source of a stream"
    ],
    "a": [1, 2, 4],
    "h": "Dynamic tables support seamless transitions from batch to streaming"
  },  {
    "q": "What does the target lag specify for a dynamic table?",
    "options": [
      "The maximum delay allowed between base table updates and dynamic table refresh",
      "The minimum time before the table can be queried",
      "The refresh frequency of the base tables",
      "The time to live for data in the dynamic table"
    ],
    "a": [0],
    "h": "Target lag sets the maximum allowed delay between updates to base tables and the dynamic table."
  },
  {
    "q": "What are the allowed value for INITIALIZE for a dynamic table?",
      "options": [
        "ON_CREATE",
        "ON_SCHEDULE",
        "IMMEDIATE",
        "MANUAL"
      ],
    "a": [0, 1],
    "h": "ION_CREATE is initialized immediately.ON_SCHEDULE, initialization happens within the specified target lag timeframe."
  },
  {
    "q": "Dynamic table can be refreshed manually",
      "options": [
        "True",
        "False"
      ],
    "a": [0],
    "h": "ALTER DYNAMIC TABLE my_dynamic_table REFRESH"
  },{
  "q": "Which refresh modes are supported by Snowflake Dynamic Tables?",
  "options": [
    "Auto",
    "Full",
    "Partial",
    "Incremental",
    "Manual"
  ],
  "a": [0, 1, 3],
  "h": "When using the AUTO parameter, Snowflake automatically selects the most cost and time-effective refresh mode"
},{
  "q": "Can a dynamic table with incremental refresh mode be downstream of a dynamic table with full refresh mode?",
  "options": [
    "Yes, they are fully compatible.",
    "No, incremental mode is incompatible with full refresh upstream.",
    "Only if both tables have the same refresh schedule.",
    "Yes, but with manual intervention."
  ],
  "a": [1],
  "h": "Incremental refresh mode is incompatible with the complete row changes from an upstream full refresh dynamic table."
},{
  "q": "True or False: A dynamic table's target lag can be shorter than the target lag of the tables it depends on.",
  "options": ["True", "False"],
  "a": [1],
  "h": "False â€” the target lag cannot be shorter than the target lag of dependent dynamic tables."
},{
  "q": "Which of the following is a valid type of target lag for a Snowflake dynamic table?",
  "options": [
    "UPSTREAM",
    "DOWNSTREAM",
    "1 hour",
    "FULLSTREAM"
  ],
  "a": [1,2],
  "h": "Snowflake schedules refreshes slightly earlier to allow time for the refresh to complete."
},{
  "q": "data - DT1 - DT2- REPORT \n DT1 TARGET_LAG = DOWNSTREAM, DT2 TARGET_LAG = 10 minutes",
  "options": [
    "No data is updated",
    "DT2 is updated at least every 10 minutes",
    "DT1 is updated every 5 minutes.",
    "DT1 is updated every time DT2 requires updates."
  ],
  "a": [1,3]
},{
  "q": "data - DT1 - DT2- REPORT \n DT1 TARGET_LAG = 10minutes, DT2 TARGET_LAG = DOWNSTREAM",
  "options": [
    "No data is updated for DT2",
    "DT2 is updated at least every 10 minutes",
    "DT1 is updated every 10 minutes.",
    "DT1 is updated every time DT2 requires updates."
  ],
  "a": [0,2],
  "h": "This scenario should be avoided. The report query will not receive any data."
},{
  "q": "data - DT1 - DT2- REPORT \n DT1 TARGET_LAG = 5minutes, DT2 TARGET_LAG = 10minutes",
  "options": [
    "No data is updated for DT2",
    "DT2 is updated approximately every 10 minutes",
    "DT1 is updated every 5 minutes.",
    "DT1 is updated every time DT2 requires updates."
  ],
  "a": [1,2]
},{
  "q": "data - DT1 - DT2- REPORT \n DT1 TARGET_LAG = DOWNSTREAM, DT2 TARGET_LAG = DOWNSTREAM",
  "options": [
    "No data is updated for DT2",
    "DT2 is updated approximately every 10 minutes",
    "DT1 is updated every 5 minutes.",
    "DT1 is updated every time DT2 requires updates."
  ],
  "a": [0],
  "h": "Neither DT1 nor DT2 is refreshed periodically because both of them have a downstream lag, and neither has a downstream consumer with a defined lag."
},{
  "q": "Dynamic tables can be combined with the benefits of dynamic tables and Snowflake-managed Iceberg tables",
  "options": [
    "True",
    "False"
  ],
  "a": [0],
  "h": "Dynamic Iceberg tables integrate with data lakes, \n which let you store data in external cloud storage such as AWS S3 or Azure Blob Storage while being managed by Snowflake. \n These tables support ACID transactions, schema evolution, hidden partitioning, and table snapshots."
},{
  "q": "After how many consecutive scheduled refresh errors are dynamic tables automatically suspended?",
  "options": [
    "Three",
    "Five",
    "Seven",
    "Ten"
  ],
  "a": [1],
  "h": "Dynamic tables are automatically suspended after five consecutive scheduled refresh errors to prevent repeated failures."
},{
  "q": "Any dynamic tables dependent on a suspended table are ____.",
  "options": [
    "automatically refreshed",
    "automatically suspended",
    "manually refreshed",
    "needs to be manually suspended"
  ],
  "a": [1],
  "h": "Any dynamic tables dependent on a suspended table are also automatically suspended to maintain data consistency."
},{
  "q": "Dynamic tables can  be manually suspended",
  "options": [
    "True",
    "False"
  ],
  "a": [0],
  "h": "ALTER DYNAMIC TABLE my_dynamic_table SUSPEND;"
}
    ],
    "links": ["https://docs.snowflake.com/en/user-guide/dynamic-tables-target-lag#types-of-target-lag"],


    "height": 200,
    "width": 200
}
]